#!/usr/bin/env php
<?php
// PEMacs - Pure PHP TTY editor inspired by Emacs keybindings
// Requirements: PHP 7.4+, Linux TTY. No external PHP extensions. Uses stty + ANSI.

declare(strict_types=1);
// Prevent warnings from garbling the terminal screen
@ini_set('display_errors', '0');

// ---- Utility: ANSI helpers ----
class Ansi {
    public const ESC = "\033";
    public static function hideCursor(): string { return self::ESC.'[?25l'; }
    public static function showCursor(): string { return self::ESC.'[?25h'; }
    public static function clear(): string { return self::ESC.'[2J'.self::ESC.'[H'; }
    public static function move(int $row, int $col): string { return self::ESC.'['.$row.';'.$col.'H'; }
    public static function color(string $codes): string { return self::ESC.'['.$codes.'m'; }
    public static function reset(): string { return self::ESC.'[0m'; }
    public static function clearLine(): string { return self::ESC.'[2K'; }
}

// ---- Terminal control ----
final class Terminal {
    private string $sttySaved;
    public int $rows = 24;
    public int $cols = 80;

    public function __construct() {
        $this->sttySaved = rtrim(shell_exec('stty -g') ?? '');
        register_shutdown_function(function () {
            $this->restore();
        });
        $this->raw();
        $this->querySize();
        stream_set_blocking(STDIN, false);
    }

    public function raw(): void {
        // Disable XON/XOFF (Ctrl+S / Ctrl+Q) and enable raw mode
        // Enable only SIGTSTP (Ctrl+Z), but disable SIGINT/SIGQUIT so Ctrl+C remains handled by the editor
        // intr ^- and quit ^- disable the interrupt/quit keys
        shell_exec('stty -ixon -icanon -echo isig intr ^- quit ^- min 1 time 0');
        // Enter the alternate screen in a portable way
        $smcup = rtrim(shell_exec('tput smcup 2>/dev/null') ?? '');
        if ($smcup !== '') { fwrite(STDOUT, $smcup); }
        else { fwrite(STDOUT, Ansi::ESC.'[?1049h'); }
        // Clear screen and show cursor
        fwrite(STDOUT, Ansi::clear().Ansi::reset().Ansi::showCursor());
    }

    public function rawSafe(): void {
        if (function_exists('pcntl_signal')) {
            @pcntl_signal(SIGTTOU, SIG_IGN);
            @pcntl_signal(SIGTTIN, SIG_IGN);
        }
        $this->raw();
        if (function_exists('pcntl_signal')) {
            @pcntl_signal(SIGTTOU, SIG_DFL);
            @pcntl_signal(SIGTTIN, SIG_DFL);
        }
    }

    public function restore(): void {
        // Full reset: restore previous stty and reset screen + scrollback
        if ($this->sttySaved !== '') { shell_exec('stty '.$this->sttySaved); }
        // Return to the main screen in a portable way
        $rmcup = rtrim(shell_exec('tput rmcup 2>/dev/null') ?? '');
        if ($rmcup !== '') { fwrite(STDOUT, $rmcup); }
        else { fwrite(STDOUT, Ansi::ESC.'[?1049l'); }
        // Clear visible area + scrollback, move cursor home, show cursor, reset colors
        fwrite(STDOUT, "\033[3J\033[2J\033[H\033[0m\033[?25h");
        fflush(STDOUT);
    }

    public function querySize(): void {
        $out = trim(shell_exec('stty size') ?? '');
        if ($out !== '') {
            [$r, $c] = array_map('intval', preg_split('/\s+/', $out));
            if ($r > 0 && $c > 0) { $this->rows = $r; $this->cols = $c; }
        }
    }
}

// ---- Data model ----
final class Buffer {
    /** @var string[] */
    public array $lines;
    public string $filePath;
    public bool $dirty = false;

    public function __construct(string $filePath, ?string $content = null) {
        $this->filePath = $filePath;
        if ($content === null && $filePath !== '') {
            $content = is_file($filePath) ? (file_get_contents($filePath) ?: '') : '';
        }
        $content = $content ?? '';
        $content = str_replace(["\r\n", "\r"], "\n", $content);
        $this->lines = explode("\n", $content);
    }

    public function lineCount(): int { return count($this->lines); }

    public function ensureLine(int $row): void {
        while ($row >= count($this->lines)) { $this->lines[] = ''; }
    }

    public function save(): bool {
        $target = $this->filePath !== '' ? $this->filePath : 'untitled.txt';
        // Preserve original permissions if the file already exists
        $oldPerms = null;
        if (is_file($target)) {
            $p = @fileperms($target);
            if ($p !== false) {
                $oldPerms = $p & 0777;
            }
        }
        $tmp = $target.'.tmp';
        $data = implode("\n", $this->lines);
        if (@file_put_contents($tmp, $data) === false) { return false; }
        if (!@rename($tmp, $target)) {
            @unlink($tmp);
            return false;
        }
        if ($oldPerms !== null) {
            @chmod($target, $oldPerms);
        }
        $this->dirty = false;
        $this->filePath = $target;
        return true;
    }

    public function loadFile(string $path): void {
        $this->filePath = $path;
        $content = is_file($path) ? (file_get_contents($path) ?: '') : '';
        $content = str_replace(["\r\n", "\r"], "\n", $content);
        $this->lines = explode("\n", $content);
        $this->dirty = false;
    }
}

final class Window {
    public int $cursorRow = 0; // 0-based in buffer
    public int $cursorCol = 0; // 0-based in chars
    public int $scrollTop = 0; // first buffer row visible
    public int $hscroll = 0;   // first buffer column visible (horizontal)
    public int $topRow = 1;    // 1-based terminal position
    public int $height = 0;    // lines available for text (excl status)
    public int $width = 0;
    public bool $hasMark = false;
    public int $markRow = 0;   // selection anchor
    public int $markCol = 0;
    public Buffer $buffer;     // buffer associated to this window

    public function __construct(int $topRow, int $height, int $width, Buffer $buffer) {
        $this->topRow = $topRow;
        $this->height = max(1, $height);
        $this->width = $width;
        $this->buffer = $buffer;
    }

    public function clampCursor(Buffer $buf): void {
        $this->cursorRow = max(0, min($buf->lineCount()-1, $this->cursorRow));
        $line = $buf->lines[$this->cursorRow] ?? '';
        $this->cursorCol = max(0, min(strlen($line), $this->cursorCol));
    }

    public function ensureCursorVisible(Buffer $buf): void {
        if ($this->cursorRow < $this->scrollTop) { $this->scrollTop = $this->cursorRow; }
        if ($this->cursorRow >= $this->scrollTop + ($this->height-1)) {
            $this->scrollTop = $this->cursorRow - ($this->height-2);
        }
        if ($this->scrollTop < 0) { $this->scrollTop = 0; }
        // Horizontal
        if ($this->cursorCol < $this->hscroll) { $this->hscroll = $this->cursorCol; }
        if ($this->cursorCol >= $this->hscroll + max(1, $this->width-1)) {
            $this->hscroll = max(0, $this->cursorCol - max(1, $this->width-10));
        }
    }

    public function selectionBounds(): ?array {
        if (!$this->hasMark) { return null; }
        $a = [$this->markRow, $this->markCol];
        $b = [$this->cursorRow, $this->cursorCol];
        if ($a === $b) { return null; }
        // Normalize
        if ($b[0] < $a[0] || ($b[0] === $a[0] && $b[1] < $a[1])) { [$a, $b] = [$b, $a]; }
        return [$a, $b];
    }
}

// ---- Renderer and Highlighter ----
final class Palette {
    // Colors inspired by a classic terminal look
    // Emacs-like: base fg white on black, comments gray, strings yellow, keywords bright magenta, variables cyan
    public static function base(): string { return '37;40'; }
    public static function comment(): string { return '37'; }
    // Strings bright red by request
    public static function string(): string { return '91'; }
    public static function keyword(): string { return '95'; }
    public static function variable(): string { return '33'; }
    public static function number(): string { return '94'; }
    public static function htmlTag(): string { return '35'; }
    public static function htmlAttr(): string { return '36'; }
    public static function status(): string { return '30;47'; }
    public static function activeStatus(): string { return '30;46'; }
    // Reverse video for selected text
    public static function selection(): string { return '7'; }
    // Function/method names: bright blue
    public static function functionName(): string { return '94'; }
    // Class names: greenish
    public static function className(): string { return '92'; }
    // Object property after '->': brownish (soft yellow)
    public static function propertyName(): string { return '33'; }
    // Boolean constants
    public static function constTrue(): string { return '92'; }
    public static function constFalse(): string { return '96'; }
}

final class Highlighter {
    public static array $phpKeywords = [
        'abstract','and','array','as','break','callable','case','catch','class','clone','const','continue','declare','default','do','else','elseif','enddeclare','endfor','endforeach','endif','endswitch','endwhile','extends','final','finally','fn','for','foreach','function','global','goto','if','implements','include','include_once','instanceof','insteadof','interface','isset','list','match','namespace','new','or','print','private','protected','public','require','require_once','return','static','switch','throw','trait','try','unset','use','var','while','xor','yield'
    ];
    public static array $jsKeywords = [
        'break','case','catch','class','const','continue','debugger','default','delete','do','else','export','extends','finally','for','function','if','import','in','instanceof','let','new','return','super','switch','this','throw','try','typeof','var','void','while','with','yield'
    ];

    public static function colorize(string $line): string {
        $colored = '';
        $i = 0; $len = strlen($line);
        while ($i < $len) {
            $ch = $line[$i];
            // Class declaration (case-insensitive): highlight keyword and class name
            if (preg_match('/^([cC][lL][aA][sS][sS])\s+([a-zA-Z_][a-zA-Z0-9_]*)/', substr($line, $i), $mc)) {
                $kw = $mc[1]; $name = $mc[2];
                $colored .= Ansi::color(Palette::keyword()).$kw.Ansi::reset().' ';
                $colored .= Ansi::color(Palette::className()).$name.Ansi::reset();
                $i += strlen($kw) + 1 + strlen($name);
                continue;
            }
            // Object access: ->property or ->method()
            if ($ch === '-' && $i+1 < $len && $line[$i+1] === '>') {
                // include the arrow as-is
                $colored .= '->';
                $i += 2;
                // optional spaces then identifier
                if (preg_match('/^\s*([a-zA-Z_][a-zA-Z0-9_]*)/', substr($line, $i), $mm)) {
                    $match = $mm[0];
                    $name = $mm[1];
                    $spacesLen = strlen($match) - strlen($name);
                    if ($spacesLen > 0) { $colored .= substr($match, 0, $spacesLen); }
                    $i += strlen($match);
                    // lookahead for method call '('
                    $k = $i; while ($k < $len && $line[$k] === ' ') { $k++; }
                    if ($k < $len && $line[$k] === '(') {
                        // method: white
                        $colored .= Ansi::color(Palette::functionName()).$name.Ansi::reset();
                    } else {
                        // property: brownish
                        $colored .= Ansi::color(Palette::propertyName()).$name.Ansi::reset();
                    }
                }
                // Always continue after handling '->' to avoid printing an extra '-'
                continue;
            }
            // Function names (simple heuristic: identifier followed by '(' with no $ in front)
            if (preg_match('/^([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/', substr($line, $i), $mf)) {
                $name = $mf[1];
                if ($i===0 || ($i>0 && $line[$i-1] !== '$')) {
                    $colored .= Ansi::color(Palette::functionName()).$name.Ansi::reset();
                    $i += strlen($name);
                    continue;
                }
            }
            // Strings
            if ($ch === '"' || $ch === "'") {
                [$tok, $end] = self::consumeString($line, $i, $ch);
                $colored .= Ansi::color(Palette::string()).$tok.Ansi::reset();
                $i = $end; continue;
            }
            // Line comment // or #
            if ($ch === '/' && $i+1 < $len && $line[$i+1] === '/') {
                $tok = substr($line, $i);
                $colored .= Ansi::color(Palette::comment()).$tok.Ansi::reset();
                break;
            }
            if ($ch === '#') {
                $tok = substr($line, $i);
                $colored .= Ansi::color(Palette::comment()).$tok.Ansi::reset();
                break;
            }
            // PHP inline open/close tags treated as plain
            if ($ch === '<' && substr($line, $i, 5) === '<?php') {
                $colored .= substr($line, $i, 5); $i += 5; continue;
            }
            if ($ch === '?' && substr($line, $i, 2) === '?>') {
                $colored .= '?>'; $i += 2; continue;
            }
            // HTML tag
            if ($ch === '<') {
                if (preg_match('/^<\/?[a-zA-Z0-9\-]+/', substr($line, $i), $m)) {
                    $tok = $m[0];
                    $colored .= Ansi::color(Palette::htmlTag()).$tok.Ansi::reset();
                    $i += strlen($tok);
                    // Attributes
                    while ($i < $len && preg_match('/^\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*/', substr($line, $i), $ma)) {
                        $colored .= $ma[0];
                        $i += strlen($ma[0]);
                        if ($i < $len && $line[$i] === '=') {
                            $colored .= '='; $i++;
                            // Value
                            if ($i < $len && ($line[$i] === '"' || $line[$i] === "'")) {
                                [$sv, $end] = self::consumeString($line, $i, $line[$i]);
                                $colored .= Ansi::color(Palette::string()).$sv.Ansi::reset();
                                $i = $end;
                            }
                        }
                    }
                    // Closing '>' if present
                    if ($i < $len && ($line[$i] === '>' || ($line[$i] === '/' && $i+1 < $len && $line[$i+1] === '>'))) {
                        $close = ($line[$i] === '/') ? '/>' : '>';
                        $colored .= Ansi::color(Palette::htmlTag()).$close.Ansi::reset();
                        $i += strlen($close);
                    }
                    continue;
                }
            }
            // Numbers
            if (ctype_digit($ch)) {
                if (preg_match('/^\d+(?:\.\d+)?/', substr($line, $i), $m)) {
                    $colored .= Ansi::color(Palette::number()).$m[0].Ansi::reset();
                    $i += strlen($m[0]);
                    continue;
                }
            }
            // Variable $foo (marroncino)
            if ($ch === '$' && preg_match('/^\$[a-zA-Z_][a-zA-Z0-9_]*/', substr($line, $i), $m)) {
                $colored .= Ansi::color(Palette::variable()).$m[0].Ansi::reset();
                $i += strlen($m[0]);
                continue;
            }
            // Keywords (PHP/JS) e booleani true/false colorati
            if (preg_match('/^[a-zA-Z_][a-zA-Z0-9_]*/', substr($line, $i), $m)) {
                $w = $m[0];
                if ($w === 'true') { $colored .= Ansi::color(Palette::constTrue()).$w.Ansi::reset(); $i += strlen($w); continue; }
                if ($w === 'false') { $colored .= Ansi::color(Palette::constFalse()).$w.Ansi::reset(); $i += strlen($w); continue; }
                if (in_array($w, self::$phpKeywords, true) || in_array($w, self::$jsKeywords, true)) {
                    $colored .= Ansi::color(Palette::keyword()).$w.Ansi::reset();
                } else {
                    $colored .= $w;
                }
                $i += strlen($w);
                continue;
            }

            // Default char
            $colored .= $ch; $i++;
        }
        return $colored;
    }

    private static function consumeString(string $line, int $start, string $quote): array {
        $i = $start; $len = strlen($line);
        $buf = '';
        $buf .= $line[$i++];
        $escaped = false;
        while ($i < $len) {
            $ch = $line[$i++];
            $buf .= $ch;
            if ($escaped) { $escaped = false; continue; }
            if ($ch === '\\') { $escaped = true; continue; }
            if ($ch === $quote) { break; }
        }
        return [$buf, $i];
    }
}

final class Renderer {
    private Terminal $term;
    /** @var Window[] */
    private array $windows;
    private int $activeIndex = 0;
    private string $statusMsg = '';
    /** @var array<int,string> righe renderizzate nell'ultimo frame (contenuto con SGR, senza movimenti) */
    private array $lastLineContent = [];
    /** @var array<int,?array{start:int,len:int,seg:string}> overlay selezione per riga schermo */
    private array $lastSelSeg = [];
    private string $lastStatusBar = '';
    private string $topOverlay = '';

    public function __construct(Terminal $term, array $windows) {
        $this->term = $term; $this->windows = $windows;
    }

    public function setWindows(array $windows, int $activeIndex): void { $this->windows = $windows; $this->activeIndex = $activeIndex; }
    public function setStatus(string $msg): void { $this->statusMsg = $msg; }
    public function activeIndex(): int { return $this->activeIndex; }
    public function invalidate(): void { $this->lastLineContent = []; $this->lastSelSeg = []; $this->lastStatusBar = ''; }
    public function setTopOverlay(string $msg): void { $this->topOverlay = $msg; $this->invalidate(); }

    public function draw(): void {
        $this->term->querySize();
        $totalRows = $this->term->rows; $cols = $this->term->cols;
        // Recompute window sizes (split horizontal)
        if (count($this->windows) === 1) {
            $this->windows[0]->topRow = 1;
            $this->windows[0]->height = $totalRows - 1; // status bar
            $this->windows[0]->width = $cols;
        } else {
            $upper = $this->windows[0];
            $lower = $this->windows[1];
            $half = intdiv($totalRows - 1, 2);
            $upper->topRow = 1; $upper->height = max(1, $half-1); $upper->width = $cols;
            // separator line
            $sepRow = 1 + $upper->height;
            $lower->topRow = $sepRow + 1; $lower->height = ($totalRows - 1) - $upper->height - 1; $lower->width = $cols;
            $this->windows = [$upper, $lower];
        }

        $out = Ansi::hideCursor();
        // (top overlay will be drawn at the end so it stays over the first line)
        foreach ($this->windows as $wi => $w) {
            // Draw text area (diff-aware per-row redraw)
            for ($r = 0; $r < $w->height; $r++) {
                $screenRow = $w->topRow + $r;
                $bufRow = $w->scrollTop + $r;
                $line = $w->buffer->lines[$bufRow] ?? '';
                $visual = str_replace("\t", ' ', $line);
                $colored = Highlighter::colorize($visual);
                $rendered = self::sliceAnsi($colored, $w->hscroll, $w->width);
                $content = Ansi::color(Palette::base()).$rendered.Ansi::reset();

                $updatedBase = false;
                $prev = $this->lastLineContent[$screenRow] ?? null;
                if ($prev !== $content) {
                    $out .= Ansi::move($screenRow, 1).Ansi::clearLine().$content;
                    $this->lastLineContent[$screenRow] = $content;
                    $updatedBase = true;
                }

                // Selection overlay: apply only when changed or base line updated
                $selInfo = null;
                $sel = $w->selectionBounds();
                if ($sel && $bufRow >= $sel[0][0] && $bufRow <= $sel[1][0]) {
                    $startCol = ($bufRow === $sel[0][0]) ? $sel[0][1] : 0;
                    $endCol = ($bufRow === $sel[1][0]) ? $sel[1][1] : strlen($visual);
                    if ($endCol > $startCol) {
                        $startCol = max(0, $startCol - $w->hscroll);
                        $length = min($endCol - $w->hscroll - $startCol, max(0, $w->width - $startCol));
                        if ($length > 0) {
                            $seg = substr($visual, $w->hscroll + $startCol, $length);
                            $selInfo = ['start'=>$startCol, 'len'=>$length, 'seg'=>$seg];
                        }
                    }
                }
                $prevSel = $this->lastSelSeg[$screenRow] ?? null;
                if ($updatedBase) {
                    if ($selInfo !== null) {
                        $out .= Ansi::move($screenRow, 1 + $selInfo['start']).Ansi::color(Palette::selection()).$selInfo['seg'].Ansi::reset();
                    }
                    $this->lastSelSeg[$screenRow] = $selInfo;
                } else if (($selInfo === null && $prevSel !== null) || ($selInfo !== null && $prevSel !== null && ($selInfo['start'] !== $prevSel['start'] || $selInfo['len'] !== $prevSel['len'] || $selInfo['seg'] !== $prevSel['seg'])) || ($selInfo !== null && $prevSel === null)) {
                    // If the overlay changed but the base line didn't, redraw the base line and then the overlay
                    $out .= Ansi::move($screenRow, 1).Ansi::clearLine().$content;
                    if ($selInfo !== null) {
                        $out .= Ansi::move($screenRow, 1 + $selInfo['start']).Ansi::color(Palette::selection()).$selInfo['seg'].Ansi::reset();
                    }
                    $this->lastSelSeg[$screenRow] = $selInfo;
                    $this->lastLineContent[$screenRow] = $content;
                }
            }
            // If there is a second window, draw the horizontal separator as an info bar for the upper pane
            if (count($this->windows) > 1 && $wi === 0) {
                $sepRow = $w->topRow + $w->height;
                $buf = $w->buffer;
                $status = ($buf->dirty ? '*' : '-') . ' ' . ($buf->filePath !== '' ? $buf->filePath : '[No Name]');
                $percent = (int)round((($w->cursorRow+1) / max(1, $buf->lineCount())) * 100);
                $pos = 'L '.($w->cursorRow+1).', C '.($w->cursorCol+1).' ('.$percent.'%)';
                $left = $status.'  '.$pos.'  '.($this->activeIndex === $wi && $this->statusMsg !== '' ? $this->statusMsg : '');
                $right = '';
                $space = max(0, $this->term->cols - strlen($left) - strlen($right));
                $sepBar = Ansi::color(Palette::activeStatus()).str_pad($left, $this->term->cols - strlen($right) - $space, ' ').str_repeat(' ', $space).$right.Ansi::reset();
                $sepContent = $sepBar;
                if (($this->lastLineContent[$sepRow] ?? null) !== $sepContent) {
                    $out .= Ansi::move($sepRow, 1).Ansi::clearLine().$sepContent;
                    $this->lastLineContent[$sepRow] = $sepContent;
                    $this->lastSelSeg[$sepRow] = null;
                }
            }
        }

        // Status bar (diff-aware) for the BOTTOM window (independent of active pane)
        $bottomIdx = max(0, count($this->windows)-1);
        $act = $this->windows[$bottomIdx];
        $buf = $act->buffer;
        $status = ($buf->dirty ? '*' : '-') . ' ' . ($buf->filePath !== '' ? $buf->filePath : '[No Name]');
        $percent = (int)round((($act->cursorRow+1) / max(1, $buf->lineCount())) * 100);
        $pos = 'L '.($act->cursorRow+1).', C '.($act->cursorCol+1).' ('.$percent.'%)';
        // Emacs-like: position info near the left
        $left = $status.'  '.$pos.'  '.(($this->statusMsg !== '' && $this->activeIndex === $bottomIdx) ? $this->statusMsg : '');
        $right = '';
        $space = max(0, $this->term->cols - strlen($left) - strlen($right));
        $bar = Ansi::color(Palette::activeStatus()).str_pad($left, $this->term->cols - strlen($right) - $space, ' ').str_repeat(' ', $space).$right.Ansi::reset();
        if ($this->lastStatusBar !== $bar) {
            $out .= Ansi::move($this->term->rows, 1).Ansi::clearLine().$bar;
            $this->lastStatusBar = $bar;
        }

        // Place cursor
        $cur = $this->windows[$this->activeIndex];
        $cur->clampCursor($cur->buffer);
        $cur->ensureCursorVisible($cur->buffer);
        $cursorRowOnScreen = $cur->topRow + ($cur->cursorRow - $cur->scrollTop);
        $cursorColOnScreen = 1 + max(0, $cur->cursorCol - $cur->hscroll);
        // Draw top overlay last, in overlay mode (does not change layout)
        if ($this->topOverlay !== '') {
            $msg = $this->topOverlay;
            $right = '';
            $left = $msg;
            $space = max(0, $this->term->cols - strlen($left) - strlen($right));
            $barTop = Ansi::color(Palette::activeStatus()).str_pad($left, $this->term->cols - strlen($right) - $space, ' ').str_repeat(' ', $space).$right.Ansi::reset();
            $out .= Ansi::move(1, 1).Ansi::clearLine().$barTop;
        }
        $out .= Ansi::move($cursorRowOnScreen, $cursorColOnScreen).Ansi::showCursor();

        fwrite(STDOUT, $out);
    }

    // Takes a string with ANSI sequences and returns a visual-column slice [start, start+width)
    private static function sliceAnsi(string $s, int $start, int $width): string {
        $out = ''; $vis = 0; $i = 0; $len = strlen($s);
        $collect = false; $end = $start + $width;
        while ($i < $len && $vis < $end) {
            $ch = $s[$i];
            if ($ch === "\x1b") { // copy whole SGR sequence without counting columns
                $m = null;
                if (preg_match('/\x1b\[[0-9;]*m/', substr($s, $i), $m)) {
                    if ($vis >= $start) { $out .= $m[0]; }
                    $i += strlen($m[0]);
                    continue;
                }
            }
            if ($vis >= $start && $vis < $end) { $out .= $ch; }
            $vis++; $i++;
        }
        return $out;
    }
}

// ---- Key handling ----
final class Keys {
    public const CTRL = 1; // value is ord(letter)
    public const ALT = 2;  // value is char
    public const ARROW = 3; // value 'up','down','left','right'
    public const SPECIAL = 4; // 'home','end','pgup','pgdn','del','backspace','enter','tab'
    public const ASCII = 5; // printable char
}

final class Input {
    private ?array $pending = null; // for Ctrl-x prefix handling

    public function readKey(): array {
        // Redraw request after SIGCONT: exit immediately to allow redraw
        if (($GLOBALS['__pemacs_sigcont'] ?? false) === true) { return [Keys::SPECIAL, 'sigcont']; }
        // Wait for a byte
        $c = fread(STDIN, 1);
        while ($c === '' || $c === false) {
            if (($GLOBALS['__pemacs_sigcont'] ?? false) === true) { return [Keys::SPECIAL, 'sigcont']; }
            usleep(10000);
            $c = fread(STDIN, 1);
        }

        // Handle Enter first to avoid CR being interpreted as Ctrl+M
        if ($c === "\r" || $c === "\n") return [Keys::SPECIAL, 'enter'];
        // Handle Tab before CTRL (otherwise it becomes Ctrl+i)
        if ($c === "\t") return [Keys::SPECIAL, 'tab'];

        $ord = ord($c);
        // Ctrl keys: 1..26 map to Ctrl+A..Ctrl+Z (Ctrl+Space is NUL -> 0)
        if ($ord === 0) { return [Keys::CTRL, ' ']; }
        if ($ord >= 1 && $ord <= 26) {
            return [Keys::CTRL, chr($ord + 96)];
        }
        if ($ord === 127) return [Keys::SPECIAL, 'backspace'];
        if ($c === "\x1b") { // ESC sequences
            $seq = $c;
            // Try to read rest (non-blocking). Wait briefly
            usleep(1000);
            $seq .= (fread(STDIN, 16) ?: '');
            // Arrows and keys: handle CSI sequences with optional modifier like ;5 (Ctrl)
            if (preg_match('/\x1b\[([0-9]+)(?:;([0-9]+))?~/', $seq, $m)) {
                $n = intval($m[1]); $mod = isset($m[2]) ? intval($m[2]) : 0;
                $spec = ['1'=>'home','3'=>'del','4'=>'end','5'=>'pgup','6'=>'pgdn','7'=>'home','8'=>'end'][$n] ?? '';
                if ($spec !== '') {
                    if ($mod === 5 && ($n===5 || $n===6)) { // Ctrl+PgUp/PgDn
                        return [Keys::SPECIAL, $n===5 ? 'ctrl_pgup' : 'ctrl_pgdn'];
                    }
                    return [Keys::SPECIAL, $spec];
                }
            }
            // Home/End alternate forms: ESC [ H / ESC [ F, or ESC O H / ESC O F
            if (preg_match('/\x1b\[(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            // CSI 1;5H/1;5F etc (with modifiers)
            if (preg_match('/\x1b\[(?:1;\d+)(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1bO(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            // Arrows with optional modifiers: ESC [ 1 ; 5 A  (Ctrl+Up), etc.
            if (preg_match('/\x1b\[(?:1;([0-9]+))?([ABCD])/', $seq, $m)) {
                $mod = isset($m[1]) ? intval($m[1]) : 0; $code = $m[2];
                if ($mod === 5 && ($code === 'A' || $code === 'B')) { // Ctrl + Up/Down
                    return [Keys::SPECIAL, $code === 'A' ? 'ctrl_up' : 'ctrl_down'];
                }
                $map = ['A'=>'up','B'=>'down','C'=>'right','D'=>'left'];
                return [Keys::ARROW, $map[$code]];
            }
            // Alt+key: ESC <char>
            $rest = substr($seq, 1);
            if ($rest !== '') {
                $k = $rest[0];
                // Alt+Backspace variants
                if ($k === "\x7f" || $k === "\x08") { return [Keys::ALT, 'backspace']; }
                // Alt combined with slash or letters
                return [Keys::ALT, $k];
            }
            return [Keys::ASCII, "\x1b"];
        }
        if ($ord >= 32 && $ord <= 126) {
            return [Keys::ASCII, $c];
        }
        return [Keys::ASCII, ''];
    }

    // Non-blocking: returns null when no input is immediately available
    public function readKeyNow(): ?array {
        if (($GLOBALS['__pemacs_sigcont'] ?? false) === true) { return [Keys::SPECIAL, 'sigcont']; }
        $c = fread(STDIN, 1);
        if ($c === '' || $c === false) { return null; }

        if ($c === "\r" || $c === "\n") return [Keys::SPECIAL, 'enter'];
        if ($c === "\t") return [Keys::SPECIAL, 'tab'];

        $ord = ord($c);
        if ($ord === 0) { return [Keys::CTRL, ' ']; }
        if ($ord >= 1 && $ord <= 26) { return [Keys::CTRL, chr($ord + 96)]; }
        if ($ord === 127) return [Keys::SPECIAL, 'backspace'];
        if ($c === "\x1b") {
            $seq = $c;
            usleep(1000);
            $seq .= (fread(STDIN, 16) ?: '');
            if (preg_match('/\x1b\[([0-9]+)(?:;([0-9]+))?~/', $seq, $m)) {
                $n = intval($m[1]); $mod = isset($m[2]) ? intval($m[2]) : 0;
                $spec = ['1'=>'home','3'=>'del','4'=>'end','5'=>'pgup','6'=>'pgdn','7'=>'home','8'=>'end'][$n] ?? '';
                if ($spec !== '') {
                    if ($mod === 5 && ($n===5 || $n===6)) { return [Keys::SPECIAL, $n===5 ? 'ctrl_pgup' : 'ctrl_pgdn']; }
                    return [Keys::SPECIAL, $spec];
                }
            }
            if (preg_match('/\x1b\[(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1b\[(?:1;\d+)(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1bO(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1b\[(?:1;([0-9]+))?([ABCD])/', $seq, $m)) {
                $mod = isset($m[1]) ? intval($m[1]) : 0; $code = $m[2];
                if ($mod === 5 && ($code === 'A' || $code === 'B')) { return [Keys::SPECIAL, $code === 'A' ? 'ctrl_up' : 'ctrl_down']; }
                $map = ['A'=>'up','B'=>'down','C'=>'right','D'=>'left'];
                return [Keys::ARROW, $map[$code]];
            }
            $rest = substr($seq, 1);
            if ($rest !== '') {
                $k = $rest[0];
                if ($k === "\x7f" || $k === "\x08") { return [Keys::ALT, 'backspace']; }
                return [Keys::ALT, $k];
            }
            return [Keys::ASCII, "\x1b"];
        }
        if ($ord >= 32 && $ord <= 126) { return [Keys::ASCII, $c]; }
        return null;
    }
}

// ---- Editor Core ----
final class Editor {
    private Terminal $term;
    private Buffer $buf;
    /** @var Window[] */
    private array $wins;
    private int $active = 0;
    private Renderer $renderer;
    private Input $input;
    private string $clipboard = '';
    /** @var string[] */
    private array $killRing = [];
    private int $killRingMax = 50;
    private ?int $yankRingIndex = null;
    /** @var null|array{startRow:int,startCol:int,endRow:int,endCol:int} */
    private ?array $lastYankRegion = null;
    private bool $inYankCycle = false;
    private bool $ctrlXPrefix = false;
    private array $undoStack = [];
    private int $undoMax = 50;
    private ?array $autocomplete = null; // ['prefix'=>, 'candidates'=>[], 'index'=>int]
    private ?string $lastSearch = null; // last query
    private int $lastSearchRow = 0; // next start row for repeat
    private int $lastSearchCol = 0; // next start col for repeat
    private bool $overlayDismissOnKey = false;

    public function __construct(Terminal $term, Buffer $buf) {
        $this->term = $term; $this->buf = $buf;
        $h = $term->rows - 1; $w = $term->cols;
        $this->wins = [new Window(1, $h, $w, $buf)];
        $this->renderer = new Renderer($term, $this->wins);
        $this->input = new Input();
        $this->snapshot();
    }

    private function activeWin(): Window { return $this->wins[$this->active]; }

    private function snapshot(): void {
        // Push full snapshot for simplicity (sufficient for modest files)
        $state = [
            'lines' => $this->buf->lines,
            'dirty' => $this->buf->dirty,
            'cursorRow' => $this->activeWin()->cursorRow,
            'cursorCol' => $this->activeWin()->cursorCol,
            'scrollTop' => $this->activeWin()->scrollTop,
            'hscroll' => $this->activeWin()->hscroll,
            // Remember the last edit position (post-edit)
            'lastEditRow' => $this->activeWin()->cursorRow,
            'lastEditCol' => $this->activeWin()->cursorCol,
        ];
        $this->undoStack[] = $state;
        if (count($this->undoStack) > $this->undoMax) { array_shift($this->undoStack); }
    }

    private function undo(): void {
        if (count($this->undoStack) <= 1) { $this->setStatus('Nothing to undo'); return; }
        // With pre-edit snapshot: pop last snapshot and restore
        $state = array_pop($this->undoStack);
        // Restore buffer and cursor state
        $this->buf->lines = $state['lines'] ?? $this->buf->lines;
        $this->buf->dirty = $state['dirty'] ?? $this->buf->dirty;
        $w = $this->activeWin();
        // Center view around the cursor after restore
        $this->recenter();
        // No push: the stack now points to the previous state, allowing further undos
    }

    private function setStatus(string $msg): void { $this->renderer->setStatus($msg); }

    public function run(): void {
        fwrite(STDOUT, Ansi::clear());
        $this->renderer->draw();
        while (true) {
            if (($GLOBALS['__pemacs_sigcont'] ?? false) === true) {
                // Re-enter raw mode and alternate screen outside the signal handler
                $this->term->rawSafe();
                fwrite(STDOUT, Ansi::clear());
                usleep(20000);
                // Reapply non-blocking on STDIN (some terminals lose it after fg)
                @stream_set_blocking(STDIN, false);
                // Drain any accumulated input (keys pressed while suspended)
                while (true) {
                    $chunk = @fread(STDIN, 4096);
                    if ($chunk === '' || $chunk === false) { break; }
                    // keep draining until buffer is empty
                }
                $this->term->querySize();
                $this->renderer->invalidate();
                $this->renderer->setWindows($this->wins, $this->active);
                $this->renderer->draw();
                $GLOBALS['__pemacs_sigcont'] = false;
            }
            $key = $this->input->readKey();
            if (($this->overlayDismissOnKey ?? false) === true) {
                $this->overlayDismissOnKey = false;
                $this->renderer->setTopOverlay('');
                $this->renderer->setStatus('');
                $this->renderer->draw();
            }
            $handled = $this->dispatchKey($key);
            if ($handled === 'quit') { break; }

            // Coalescing: processa input immediatamente disponibile per ridurre redraw multipli
            $start = microtime(true);
            $steps = 0;
            while (true) {
                $next = $this->input->readKeyNow();
                if ($next === null) { break; }
                $handled = $this->dispatchKey($next);
                if ($handled === 'quit') { break 2; }
                $steps++;
                if ($steps >= 64) { break; }
                if ((microtime(true) - $start) > 0.008) { break; }
            }

            $this->renderer->setWindows($this->wins, $this->active);
            $this->renderer->draw();
        }
    }

    private function dispatchKey(array $key) {
        [$type, $val] = $key;
        $w = $this->activeWin();
        $this->renderer->setStatus('');

        if ($this->ctrlXPrefix) {
            $this->ctrlXPrefix = false;
            if ($type === Keys::CTRL && $val === 's') { $this->saveFile(); return null; }
            if ($type === Keys::CTRL && $val === 'c') { return $this->maybeQuit(); }
            if ($type === Keys::CTRL && $val === 'f') { $this->findFile(); return null; }
            if ($type === Keys::ASCII && $val === 'u') { if ($this->inYankCycle) { $this->yankPop(true); } else { $this->undo(); } return null; }
            if ($type === Keys::ASCII && $val === '2') { $this->splitHorizontal(); return null; }
            if ($type === Keys::ASCII && $val === 'o') { $this->otherWindow(); return null; }
            if ($type === Keys::ASCII && $val === '1') { $this->makeOnlyThisWindow(); return null; }
            if ($type === Keys::ASCII && $val === '0') { $this->closeCurrentWindow(); return null; }
            return null;
        }

        if ($type === Keys::CTRL && $val === 'x') { $this->ctrlXPrefix = true; $this->setStatus('C-x'); return null; }
		if ($type === Keys::CTRL && $val === 's') { $this->incrementalSearch(''); return null; }
        if ($type === Keys::SPECIAL && $val === 'sigcont') { return null; }

        if ($type === Keys::CTRL && $val === ' ') { $w->hasMark = !$w->hasMark; if ($w->hasMark) { $w->markRow=$w->cursorRow; $w->markCol=$w->cursorCol; $this->setStatus('Mark set'); } else { $this->setStatus('Mark cleared'); } return null; }
        if ($type === Keys::CTRL && $val === 'w') { $this->killRegion(); return null; }
        if ($type === Keys::CTRL && $val === 'y') { $this->yank(); return null; }

        if ($type === Keys::ALT && ($val === 'g' || $val === 'G')) { $this->gotoLinePrompt(); return null; }
        if ($type === Keys::CTRL && $val === 'l') { $this->recenter(); return null; }
        if ($type === Keys::CTRL && $val === 'e') { $this->moveEndOfLine(); return null; }
        if ($type === Keys::CTRL && $val === 'a') { $this->moveBeginningOfLine(); return null; }
        if ($type === Keys::ALT && $val === 'd') { $this->killWordForward(); return null; }
        if ($type === Keys::ALT && $val === 'backspace') { $this->backwardKillWord(); return null; }
        if ($type === Keys::ALT && ($val === 'b' || $val === 'B')) { $this->backwardWord(); return null; }
        if ($type === Keys::ALT && ($val === 'f' || $val === 'F')) { $this->forwardWord(); return null; }
        if ($type === Keys::ALT && $val === 'i') { $this->indentRegion(); return null; }
        if ($type === Keys::ALT && $val === '/') { $this->autocomplete(); return null; }
        if ($type === Keys::ALT && ($val === 'y' || $val === 'Y')) { $this->yankPop(false); return null; }
        // Alias: Ctrl+u behaves like C-x u (undo; or yank-pop forward if in yank cycle)
        if ($type === Keys::CTRL && $val === 'u') { if ($this->inYankCycle) { $this->yankPop(true); } else { $this->undo(); } return null; }
        // Ctrl+Alt+f / Ctrl+Alt+b per saltare tra parentesi corrispondenti
        if ($type === Keys::ALT && $val === "\x06") { $this->jumpToMatchingBracketForward(); return null; } // M-C-f
        if ($type === Keys::ALT && $val === "\x02") { $this->jumpToMatchingBracketBackward(); return null; } // M-C-b
        // ESC ESC ESC clears mark (like Emacs)
        if ($type === Keys::ASCII && $val === "\x1b") { $this->escCount = ($this->escCount ?? 0) + 1; if ($this->escCount >= 3) { $w->hasMark = false; $this->escCount = 0; $this->setStatus(''); } return null; } else { $this->escCount = 0; }
        // (C-u) removed: use C-x u for undo or forward yank-pop when in yank cycle

        switch ($type) {
            case Keys::ARROW:
                $this->moveCursor($val);
                return null;
            case Keys::SPECIAL:
                if ($val === 'enter') { $this->newlineWithIndent(); return null; }
                if ($val === 'backspace') { $this->backspace(); return null; }
                if ($val === 'del') { $this->deleteForward(); return null; }
                if ($val === 'home') { $this->moveBeginningOfLine(); return null; }
                if ($val === 'end') { $this->moveEndOfLine(); return null; }
                if ($val === 'ctrl_pgup') { $this->jumpBlankBlock(-1); return null; }
                if ($val === 'ctrl_pgdn') { $this->jumpBlankBlock(1); return null; }
                if ($val === 'ctrl_up') { $this->jumpBlankBlock(-1); return null; }
                if ($val === 'ctrl_down') { $this->jumpBlankBlock(1); return null; }
                if ($val === 'pgup') {
                    $delta = max(1, $w->height);
                    $oldTop = $w->scrollTop;
                    $maxStart = max(0, $w->buffer->lineCount() - $w->height);
                    $newTop = max(0, $oldTop - $delta);
                    if ($newTop > $maxStart) { $newTop = $maxStart; }
                    $moved = $newTop - $oldTop; // negative or zero
                    $w->scrollTop = $newTop;
                    // Keep cursor on the same screen row
                    $w->cursorRow = min(max(0, $w->cursorRow + $moved), max(0,$w->buffer->lineCount()-1));
                    $line = $w->buffer->lines[$w->cursorRow] ?? '';
                    $w->cursorCol = min($w->cursorCol, strlen($line));
                    return null;
                }
                if ($val === 'pgdn') {
                    $delta = max(1, $w->height);
                    $oldTop = $w->scrollTop;
                    $maxStart = max(0, $w->buffer->lineCount() - $w->height);
                    $newTop = min($maxStart, $oldTop + $delta);
                    $moved = $newTop - $oldTop; // positive or zero
                    $w->scrollTop = $newTop;
                    // Keep cursor on the same screen row
                    $w->cursorRow = min(max(0, $w->cursorRow + $moved), max(0,$w->buffer->lineCount()-1));
                    $line = $w->buffer->lines[$w->cursorRow] ?? '';
                    $w->cursorCol = min($w->cursorCol, strlen($line));
                    // If mark is active and we are at end-of-buffer, extend selection to end of last line
                    if ($w->hasMark && $w->cursorRow === $w->buffer->lineCount()-1) {
                        $last = $w->buffer->lines[$w->cursorRow] ?? '';
                        $w->cursorCol = strlen($last);
                    }
                    return null;
                }
                if ($val === 'tab') { $this->indentCurrentOrRegion(); return null; }
                return null;
            case Keys::ASCII:
                if ($val !== '') { if ($val === "\f") { $this->recenter(); return null; } $this->insertChar($val); return null; }
                return null;
        }
        return null;
    }

    private function insertChar(string $ch): void {
        // Snapshot before modification
        $this->snapshot();
        $w = $this->activeWin(); $row = $w->cursorRow; $col = $w->cursorCol;
        $line = $this->buf->lines[$row] ?? '';
        // Outdent if first non-space is )}] and we are at leading spaces
        if (($ch === ')' || $ch === ']' || $ch === '}') && preg_match('/^\s*$/', substr($line, 0, $col))) {
            if (strlen($line) > 0 && $col > 0) {
                $pre = substr($line, 0, max(0, $col-1));
                $post = substr($line, $col);
                $line = $pre.$post; $w->cursorCol = max(0, $col-1); $col = $w->cursorCol;
            }
        }
        $newline = substr($line, 0, $col).$ch.substr($line, $col);
        $this->buf->lines[$row] = $newline;
        $w->cursorCol++;
        $this->buf->dirty = true;
        $this->autocomplete = null; // reset cycle
    }

    private function backspace(): void {
        // Snapshot before modification
        $this->snapshot();
        $w = $this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        if ($col > 0) {
            $line = $this->buf->lines[$row];
            $this->buf->lines[$row] = substr($line, 0, $col-1).substr($line, $col);
            $w->cursorCol--; $this->buf->dirty = true;
            return;
        }
        if ($row > 0) {
            $prev = $this->buf->lines[$row-1];
            $line = $this->buf->lines[$row];
            $joinCol = strlen($prev);
            $this->buf->lines[$row-1] = $prev.$line;
            array_splice($this->buf->lines, $row, 1);
            $w->cursorRow--; $w->cursorCol = $joinCol; $this->buf->dirty = true;
        }
    }

    private function deleteForward(): void {
        // Snapshot before modification
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        $line = $this->buf->lines[$row];
        if ($col < strlen($line)) {
            $this->buf->lines[$row] = substr($line, 0, $col).substr($line, $col+1);
            $this->buf->dirty = true;
        } else if ($row < $this->buf->lineCount()-1) {
            $next = $this->buf->lines[$row+1];
            $this->buf->lines[$row] = $line.$next;
            array_splice($this->buf->lines, $row+1, 1);
            $this->buf->dirty = true;
        }
    }

    private function newlineWithIndent(): void {
        // Snapshot before modification
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        $line = $this->buf->lines[$row];
        $before = substr($line, 0, $col); $after = substr($line, $col);
        $indent = preg_match('/^(\s*)/', $before, $m) ? strlen($m[1]) : 0;
        $trimPrev = rtrim($before);
        $last = $trimPrev === '' ? '' : $trimPrev[strlen($trimPrev)-1];
        if ($last === '{') { $indent += 1; }
        // If the trailing part starts with '}', reduce indent
        if (preg_match('/^\s*\}/', $after)) { $indent = max(0, $indent - 1); }
        // Indent using TABs: convert leading spaces/tabs into logical TABs
        $newLineStr = str_repeat("\t", max(0,$indent));
        $this->buf->lines[$row] = $before;
        array_splice($this->buf->lines, $row+1, 0, [$newLineStr.$after]);
        $w->cursorRow++; $w->cursorCol = $indent;
        $this->buf->dirty = true;
    }

    private function moveCursor(string $dir): void {
        $w=$this->activeWin();
        if ($dir === 'left') {
            if ($w->cursorCol > 0) { $w->cursorCol--; }
            else if ($w->cursorRow > 0) { $w->cursorRow--; $w->cursorCol = strlen($this->buf->lines[$w->cursorRow]); }
        } elseif ($dir === 'right') {
            $line = $this->buf->lines[$w->cursorRow];
            if ($w->cursorCol < strlen($line)) { $w->cursorCol++; }
            else if ($w->cursorRow < $this->buf->lineCount()-1) { $w->cursorRow++; $w->cursorCol = 0; }
        } elseif ($dir === 'up') {
            if ($w->cursorRow > 0) { $w->cursorRow--; $w->cursorCol = min($w->cursorCol, strlen($this->buf->lines[$w->cursorRow])); }
        } elseif ($dir === 'down') {
            if ($w->cursorRow < $this->buf->lineCount()-1) {
                $w->cursorRow++; $w->cursorCol = min($w->cursorCol, strlen($this->buf->lines[$w->cursorRow]));
            } else {
                // When at end-of-buffer with an active mark, extend selection to end of last line
                if ($w->hasMark) {
                    $last = $this->buf->lines[$w->cursorRow] ?? '';
                    $w->cursorCol = strlen($last);
                }
            }
        }
    }

    private function moveEndOfLine(): void {
        $w=$this->activeWin();
        $line = $this->buf->lines[$w->cursorRow] ?? '';
        $w->cursorCol = strlen($line);
        // ensure the last character is visible
        $w->hscroll = max(0, $w->cursorCol - intdiv(max(1,$w->width-1), 1));
    }

    private function moveBeginningOfLine(): void {
        $w=$this->activeWin();
        $w->cursorCol = 0;
    }

    private function isWordChar(string $ch): bool { return ctype_alnum($ch) || $ch === '_' || $ch === '$'; }

    private function forwardWord(): void {
        $w=$this->activeWin(); $line = $this->buf->lines[$w->cursorRow] ?? '';
        $i = $w->cursorCol; $n = strlen($line);
        while ($i < $n && !$this->isWordChar($line[$i])) $i++;
        while ($i < $n && $this->isWordChar($line[$i])) $i++;
        $w->cursorCol = $i;
    }

    private function backwardWord(): void {
        $w=$this->activeWin(); $line = $this->buf->lines[$w->cursorRow] ?? '';
        $i = $w->cursorCol - 1;
        while ($i > 0 && !$this->isWordChar($line[$i])) $i--;
        while ($i > 0 && $this->isWordChar($line[$i-1])) $i--;
        $w->cursorCol = max(0,$i);
    }

    private function killWordForward(): void {
        // Snapshot before modification
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol; $line = $this->buf->lines[$row] ?? '';
        $i = $col; $n = strlen($line);
        while ($i < $n && !$this->isWordChar($line[$i])) $i++;
        while ($i < $n && $this->isWordChar($line[$i])) $i++;
        $kill = substr($line, $col, $i-$col);
        $this->clipboard = $kill; $this->pushKillRing($kill);
        $this->buf->lines[$row] = substr($line, 0, $col).substr($line, $i);
        $this->buf->dirty = true;
        $this->inYankCycle = false; $this->lastYankRegion = null; $this->yankRingIndex = null;
    }

    private function backwardKillWord(): void {
        // Snapshot before modification
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol; $line = $this->buf->lines[$row] ?? '';
        $i = $col;
        while ($i > 0 && !$this->isWordChar($line[$i-1])) $i--;
        while ($i > 0 && $this->isWordChar($line[$i-1])) $i--;
        $kill = substr($line, $i, $col-$i);
        $this->clipboard = $kill; $this->pushKillRing($kill);
        $this->buf->lines[$row] = substr($line, 0, $i).substr($line, $col);
        $w->cursorCol = $i;
        $this->buf->dirty = true;
        $this->inYankCycle = false; $this->lastYankRegion = null; $this->yankRingIndex = null;
    }

    private function recenter(): void {
        $w=$this->activeWin();
        $w->scrollTop = max(0, $w->cursorRow - intdiv($w->height, 2));
        $w->hscroll = max(0, $w->cursorCol - intdiv(max(1,$w->width-1), 2));
        $this->renderer->setWindows($this->wins, $this->active);
        $this->renderer->draw();
    }

    private function recenterIfOffscreen(): void {
        $w=$this->activeWin();
        $visibleTop = $w->scrollTop;
        $visibleBottom = $w->scrollTop + max(1, $w->height-1) - 1;
        if ($w->cursorRow < $visibleTop || $w->cursorRow > $visibleBottom) {
            $this->recenter();
        }
    }

    private function jumpBlankBlock(int $dir): void {
        $w=$this->activeWin(); $row=$w->cursorRow; $n=$this->buf->lineCount();
        $found = $row;
        if ($dir < 0) {
            for ($r=$row-1; $r>=0; $r--) { if (trim($this->buf->lines[$r]) === '') { $found = $r; break; } }
        } else {
            for ($r=$row+1; $r<$n; $r++) { if (trim($this->buf->lines[$r]) === '') { $found = $r; break; } }
        }
        $w->cursorRow = $found; $w->cursorCol = 0; $w->ensureCursorVisible($this->buf);
        // recenter per velocit visiva
        $this->recenter();
    }

    private function jumpToMatchingBracketForward(): void {
        $w = $this->activeWin();
        [$row,$col] = [$w->cursorRow, $w->cursorCol];
        $line = $this->buf->lines[$row] ?? '';
        $startChar = null; $startRow = $row; $startCol = $col;
        $opens = ['('=>')','['=>']','{'=>'}'];
        $closes = array_flip($opens);
        $c = ($col < strlen($line)) ? $line[$col] : null;
        $cPrev = ($col > 0 && $col-1 < strlen($line)) ? $line[$col-1] : null;
        if ($c !== null && isset($opens[$c])) { $startChar = $c; $startCol = $col; }
        elseif ($cPrev !== null && isset($opens[$cPrev])) { $startChar = $cPrev; $startCol = $col-1; }
        else {
            // Widen: look for an opening bracket to the left on the same line
            $k = $col-1; while ($k >= 0 && ($line[$k] === ' ' || $line[$k] === "\t")) { $k--; }
            if ($k >= 0 && isset($opens[$line[$k]])) { $startChar = $line[$k]; $startCol = $k; }
            // If not found and at line start, check the previous line
            if ($startChar === null && $col === 0 && $row > 0) {
                $pl = $this->buf->lines[$row-1]; $k = strlen($pl) - 1;
                while ($k >= 0 && ($pl[$k] === ' ' || $pl[$k] === "\t")) { $k--; }
                if ($k >= 0 && isset($opens[$pl[$k]])) { $startChar = $pl[$k]; $startRow = $row-1; $startCol = $k; }
            }
            if ($startChar === null) { $this->setStatus('No opening bracket at point'); return; }
        }
        $target = $opens[$startChar];
        $depth = 1; $r = $startRow; $cidx = $startCol;
        $inStr = null; $escaped = false; $inLineComment = false; $inBlockComment = false;
        while (true) {
            // advance one char
            $cidx++;
            while (true) {
                $ln = $this->buf->lines[$r] ?? null;
                if ($ln === null) { $this->setStatus('No match'); return; }
                if ($cidx < strlen($ln)) { break; }
                // new line
                $r++; $cidx = 0; $inLineComment = false; $escaped = false; // reset comment at newline
            }
            $ch = $this->buf->lines[$r][$cidx];
            if ($inLineComment) { continue; }
            if ($inBlockComment) { if ($ch === '*' && ($cidx+1) < strlen($this->buf->lines[$r]) && $this->buf->lines[$r][$cidx+1] === '/') { $inBlockComment = false; $cidx++; } continue; }
            if ($inStr !== null) {
                if ($escaped) { $escaped = false; continue; }
                if ($ch === '\\') { $escaped = true; continue; }
                if ($ch === $inStr) { $inStr = null; }
                continue;
            }
            // Start string or line comment
            if ($ch === '"' || $ch === "'") { $inStr = $ch; continue; }
            if ($ch === '/' && ($cidx+1) < strlen($this->buf->lines[$r]) && $this->buf->lines[$r][$cidx+1] === '/') { $inLineComment = true; continue; }
            if ($ch === '/' && ($cidx+1) < strlen($this->buf->lines[$r]) && $this->buf->lines[$r][$cidx+1] === '*') { $inBlockComment = true; $cidx++; continue; }
            if ($ch === '#') { $inLineComment = true; continue; }
            // Depth tracking: considera SOLO lo stesso tipo di parentesi
            if ($ch === $startChar) { $depth++; continue; }
            if ($ch === $target) { $depth--; if ($depth === 0) { $w->cursorRow = $r; $w->cursorCol = $cidx; $this->recenterIfOffscreen(); return; } }
        }
    }

    private function jumpToMatchingBracketBackward(): void {
        $w = $this->activeWin();
        [$row,$col] = [$w->cursorRow, $w->cursorCol];
        $line = $this->buf->lines[$row] ?? '';
        $opens = ['('=>')','['=>']','{'=>'}'];
        $closes = array_flip($opens);
        $startChar = null; $startRow = $row; $startCol = $col;
        $c = ($col > 0) ? $line[$col-1] : null; // char before cursor
        $cHere = ($col < strlen($line)) ? $line[$col] : null;
        if ($cHere !== null && isset($closes[$cHere])) { $startChar = $cHere; $startCol = $col; }
        elseif ($c !== null && isset($closes[$c])) { $startChar = $c; $startCol = $col-1; }
        else { $this->setStatus('No closing bracket at point'); return; }
        $target = $closes[$startChar];
        $depth = 1; $r = $startRow; $cidx = $startCol;
        $inStr = null; $escaped = false; $inLineComment = false; $inBlockComment = false;
        while (true) {
            // move back one char
            $cidx--;
            while ($cidx < 0) {
                $r--; if ($r < 0) { $this->setStatus('No match'); return; }
                $ln = $this->buf->lines[$r];
                $cidx = strlen($ln) - 1; $inLineComment = false; $escaped = false;
            }
            $ch = $this->buf->lines[$r][$cidx];
            if ($inLineComment) { continue; }
            if ($inBlockComment) { if ($ch === '/' && $cidx > 0 && $this->buf->lines[$r][$cidx-1] === '*') { $inBlockComment = false; $cidx--; } continue; }
            if ($inStr !== null) {
                // naive skip backwards: exit string when same quote seen not escaped
                if ($ch === $inStr && !$escaped) { $inStr = null; continue; }
                if ($ch === '\\' && !$escaped) { $escaped = true; continue; }
                $escaped = false; continue;
            }
            // Enter string or ignore comments when scanning backward (best-effort)
            if ($ch === '"' || $ch === "'") { $inStr = $ch; $escaped = true; continue; }
            if ($ch === '/' && $cidx > 0 && $this->buf->lines[$r][$cidx-1] === '*') { $inBlockComment = true; $cidx--; continue; }
            // Depth tracking: considera SOLO lo stesso tipo di parentesi
            if ($ch === $startChar) { $depth++; continue; }
            if ($ch === $target) { $depth--; if ($depth === 0) { $w->cursorRow = $r; $w->cursorCol = $cidx; $this->recenterIfOffscreen(); return; } }
        }
    }

    private function regionText(Window $w): ?array {
        $sel = $w->selectionBounds();
        if (!$sel) { return null; }
        [$a, $b] = $sel; // [row,col]
        $lines = [];
        for ($r=$a[0]; $r<=$b[0]; $r++) {
            $line = $this->buf->lines[$r];
            $start = ($r===$a[0]) ? $a[1] : 0;
            $end = ($r===$b[0]) ? $b[1] : strlen($line);
            $lines[] = substr($line, $start, max(0,$end-$start));
        }
        return [$a,$b,$lines];
    }

    private function killRegion(): void {
        // Snapshot before modification
        $this->snapshot();
        $w=$this->activeWin(); $rg = $this->regionText($w);
        if (!$rg) { $this->setStatus('No selection'); return; }
        [$a,$b,$lines] = $rg; $this->clipboard = implode("\n", $lines);
        $this->pushKillRing($this->clipboard);
        // Delete region
        if ($a[0] === $b[0]) {
            $line = $this->buf->lines[$a[0]];
            $this->buf->lines[$a[0]] = substr($line, 0, $a[1]).substr($line, $b[1]);
        } else {
            $first = substr($this->buf->lines[$a[0]], 0, $a[1]);
            $last = substr($this->buf->lines[$b[0]], $b[1]);
            $newFirst = $first.$last;
            array_splice($this->buf->lines, $a[0], $b[0]-$a[0]+1, [$newFirst]);
        }
        $w->cursorRow = $a[0]; $w->cursorCol = $a[1];
        $w->hasMark = false; $this->buf->dirty = true;
        $this->setStatus('Killed');
        $this->inYankCycle = false; $this->lastYankRegion = null; $this->yankRingIndex = null;
    }

    private function yank(): void {
        // Snapshot before modification
        $this->snapshot();
        $text = $this->killRing[0] ?? $this->clipboard;
        if ($text === '') { $this->setStatus('Clipboard empty'); return; }
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        $lines = explode("\n", $text);
        if (count($lines) === 1) {
            $line = $this->buf->lines[$row];
            $this->buf->lines[$row] = substr($line, 0, $col).$lines[0].substr($line, $col);
            $w->cursorCol = $col + strlen($lines[0]);
            $this->lastYankRegion = ['startRow'=>$row,'startCol'=>$col,'endRow'=>$row,'endCol'=>$w->cursorCol];
        } else {
            $line = $this->buf->lines[$row];
            $first = substr($line, 0, $col).$lines[0];
            $last = substr($line, $col);
            $mid = array_slice($lines, 1, -1);
            $end = end($lines);
            $newLines = array_merge([$first], $mid, [$end.$last]);
            array_splice($this->buf->lines, $row, 1, $newLines);
            $w->cursorRow = $row + count($newLines)-1; $w->cursorCol = strlen($end);
            $this->lastYankRegion = ['startRow'=>$row,'startCol'=>$col,'endRow'=>$w->cursorRow,'endCol'=>$w->cursorCol];
        }
        $this->buf->dirty = true;
        $this->inYankCycle = true; $this->yankRingIndex = 0; $this->setStatus('Yanked');
    }

    private function pushKillRing(string $text): void {
        if ($text === '') return;
        array_unshift($this->killRing, $text);
        if (count($this->killRing) > $this->killRingMax) { array_pop($this->killRing); }
    }

    private function yankPop(bool $forward): void {
        if (!$this->inYankCycle || $this->lastYankRegion === null || $this->killRing === []) { $this->setStatus('Yank-pop only after yank'); return; }
        $count = count($this->killRing);
        if ($count <= 1) { return; }
        $idx = $this->yankRingIndex ?? 0;
        $idx = $forward ? ($idx - 1 + $count) % $count : ($idx + 1) % $count;
        $this->replaceLastYankWith($this->killRing[$idx]);
        $this->yankRingIndex = $idx; $this->inYankCycle = true; $this->setStatus('Yank-pop');
    }

    private function replaceLastYankWith(string $text): void {
        $w = $this->activeWin();
        $aRow = $this->lastYankRegion['startRow']; $aCol = $this->lastYankRegion['startCol'];
        $bRow = $this->lastYankRegion['endRow']; $bCol = $this->lastYankRegion['endCol'];
        // Delete existing region
        if ($aRow === $bRow) {
            $line = $this->buf->lines[$aRow];
            $this->buf->lines[$aRow] = substr($line, 0, $aCol).substr($line, $bCol);
            $w->cursorRow = $aRow; $w->cursorCol = $aCol;
        } else {
            $first = substr($this->buf->lines[$aRow], 0, $aCol);
            $last = substr($this->buf->lines[$bRow], $bCol);
            $newFirst = $first.$last;
            array_splice($this->buf->lines, $aRow, $bRow-$aRow+1, [$newFirst]);
            $w->cursorRow = $aRow; $w->cursorCol = $aCol;
        }
        // Insert new text at cursor (like yank)
        $row = $w->cursorRow; $col = $w->cursorCol; $lines = explode("\n", $text);
        if (count($lines) === 1) {
            $line = $this->buf->lines[$row];
            $this->buf->lines[$row] = substr($line, 0, $col).$lines[0].substr($line, $col);
            $w->cursorCol = $col + strlen($lines[0]);
            $this->lastYankRegion = ['startRow'=>$row,'startCol'=>$col,'endRow'=>$row,'endCol'=>$w->cursorCol];
        } else {
            $line = $this->buf->lines[$row];
            $first = substr($line, 0, $col).$lines[0];
            $last = substr($line, $col);
            $mid = array_slice($lines, 1, -1);
            $end = end($lines);
            $newLines = array_merge([$first], $mid, [$end.$last]);
            array_splice($this->buf->lines, $row, 1, $newLines);
            $w->cursorRow = $row + count($newLines)-1; $w->cursorCol = strlen($end);
            $this->lastYankRegion = ['startRow'=>$row,'startCol'=>$col,'endRow'=>$w->cursorRow,'endCol'=>$w->cursorCol];
        }
        $this->buf->dirty = true;
    }

    private function indentRegion(): void {
        // Snapshot before modification
        $this->snapshot();
        $w=$this->activeWin(); $sel = $w->selectionBounds();
        if (!$sel) { $this->setStatus('No selection'); return; }
        [$a,$b] = $sel;
        for ($r=$a[0]; $r<=$b[0]; $r++) {
            $line = $this->buf->lines[$r];
            // Indent like Emacs: move the line to the desired indent
            $desired = $this->desiredIndentForRow($r);
            // Costruisci prefisso di TAB
            $prefix = str_repeat("\t", max(0, $desired));
            $this->buf->lines[$r] = $prefix.ltrim($line, " \t");
        }
        // Posiziona il cursore alla colonna dell'indent desiderato
        if ($w->cursorRow >= $a[0] && $w->cursorRow <= $b[0]) {
            $w->cursorCol = $this->desiredIndentForRow($w->cursorRow);
        }
        $this->buf->dirty = true;
        $this->setStatus('Indented');
    }

    private function indentCurrentOrRegion(): void {
        // Snapshot before modification
        $this->snapshot();
        $w=$this->activeWin();
        $sel = $w->selectionBounds();
        if ($sel) { $this->indentRegion(); return; }
        $row = $w->cursorRow;
        $desired = $this->desiredIndentForRow($row);
        $this->buf->lines[$row] = str_repeat("\t", max(0,$desired)).ltrim($this->buf->lines[$row], " \t");
        $w->cursorCol = $desired;
        $this->buf->dirty = true;
        $this->setStatus('Indented');
    }

    private function desiredIndentForRow(int $row): int {
        // Count only braces { } up to the previous line, ignoring strings and comments
        $depth = 0; $inStr = null; $escaped = false; $inLineComment = false;
        for ($r = 0; $r < $row; $r++) {
            $ln = $this->buf->lines[$r] ?? '';
            $inLineComment = false; $inStr = null; $escaped = false;
            $len = strlen($ln);
            for ($i=0; $i<$len; $i++) {
                $ch = $ln[$i];
                if ($inLineComment) break;
                if ($inStr !== null) {
                    if ($escaped) { $escaped = false; continue; }
                    if ($ch === '\\') { $escaped = true; continue; }
                    if ($ch === $inStr) { $inStr = null; }
                    continue;
                }
                if ($ch === '"' || $ch === "'") { $inStr = $ch; continue; }
                if ($ch === '/' && $i+1<$len && $ln[$i+1] === '/') { $inLineComment = true; break; }
                if ($ch === '{') $depth++;
                if ($ch === '}') $depth = max(0,$depth-1);
            }
        }
        $cur = $this->buf->lines[$row] ?? '';
        if (preg_match('/^\s*\}/', $cur)) { $depth = max(0, $depth - 1); }
        return $depth;
    }

    private function gotoLinePrompt(): void {
        $num = $this->miniPrompt('Goto line: ');
        if ($num === null || $num === '') { return; }
        $line = max(1, (int)$num); $line = min($line, $this->buf->lineCount());
        $w=$this->activeWin();
        $w->cursorRow = $line-1; $w->cursorCol = 0;
        // center the view immediately; don't wait for further input
        $w->scrollTop = max(0, $w->cursorRow - intdiv($w->height,2));
        $this->renderer->setWindows($this->wins, $this->active);
        $this->renderer->draw();
        $this->setStatus('');
    }

    private function autocomplete(): void {
		$w=$this->activeWin(); $line = $this->buf->lines[$w->cursorRow]; $col=$w->cursorCol;
        $continuing = false; $prefix = '';
        // If we are at the same location as the last completion, reuse the original prefix (like Emacs dabbrev)
        if ($this->autocomplete && ($this->autocomplete['row'] ?? -1) === $w->cursorRow) {
            $startCol = $this->autocomplete['start'] ?? null;
            if ($startCol !== null && $col >= $startCol) {
                $prefix = $this->autocomplete['prefix'];
                $continuing = true;
            }
        }
        if (!$continuing) {
            if (!preg_match('/[A-Za-z_][A-Za-z0-9_]*$/', substr($line, 0, $col), $m)) { $this->setStatus('No prefix'); $this->autocomplete = null; return; }
            $prefix = $m[0];
        }
		// Cycle existing candidates without wrapping (stop at end)
		if ($continuing && $this->autocomplete) {
			$cands = $this->autocomplete['candidates']; $i = $this->autocomplete['index'] + 1;
			if ($i >= count($cands)) { $this->setStatus('No more matches'); return; }
			$this->autocomplete['index'] = $i; $word = $cands[$i];
		} else {
			// Build dabbrev-like candidates scanning upward from the cursor, then current line left of cursor.
			// Duplicates are allowed and ordered by proximity (right-to-left, bottom-to-top).
			$cands = [];
			$rows = $w->cursorRow;
			// Current line: search left of cursor from right to left
			$left = substr($line, 0, $col);
			if ($left !== '') {
				if (preg_match_all('/\\b'.preg_quote($prefix,'/').'[A-Za-z0-9_]*\\b/', $left, $mm, PREG_OFFSET_CAPTURE)) {
					$matches = $mm[0];
					for ($k=count($matches)-1; $k>=0; $k--) {
						$wordc = $matches[$k][0];
						if ($wordc !== $prefix) { $cands[] = $wordc; }
					}
				}
			}
			// Lines above
			for ($r=$rows-1; $r>=0; $r--) {
				$ln = $this->buf->lines[$r] ?? '';
				if ($ln === '') continue;
				if (preg_match_all('/\\b'.preg_quote($prefix,'/').'[A-Za-z0-9_]*\\b/', $ln, $mm, PREG_OFFSET_CAPTURE)) {
					$matches = $mm[0];
					for ($k=count($matches)-1; $k>=0; $k--) {
						$wordc = $matches[$k][0];
						if ($wordc !== $prefix) { $cands[] = $wordc; }
					}
				}
			}
			if (!$cands) { $this->setStatus('No matches'); $this->autocomplete = null; return; }
			// First candidate
			$word = $cands[0];
            // Compute start of original prefix for future cycles
            $start = $col - strlen($prefix);
			$this->autocomplete = ['prefix'=>$prefix, 'candidates'=>$cands, 'index'=>0, 'row'=>$w->cursorRow, 'start'=>$start];
		}
		// Replace prefix with word
		$start = $this->autocomplete['start'] ?? ($col - strlen($prefix));
		$this->buf->lines[$w->cursorRow] = substr($line, 0, $start).$word.substr($line, $col);
		$w->cursorCol = $start + strlen($word);
		$this->buf->dirty = true; $this->snapshot();
		$this->setStatus($word);
    }

    private function miniPrompt(string $prompt): ?string {
        // Readline-like minimal prompt in status bar
        $input = '';
        $this->renderer->setStatus($prompt.$input);
        $this->renderer->draw();
        while (true) {
            $k = (new Input())->readKey();
            [$t,$v] = $k;
            if ($t === Keys::SPECIAL && $v === 'enter') break;
            if ($t === Keys::CTRL && $v === 'g') { $input = null; break; }
            if ($t === Keys::SPECIAL && $v === 'backspace') { if ($input !== '') { $input = substr($input,0,-1); } }
            elseif ($t === Keys::ASCII && $v !== '') { if (ctype_digit($v)) { $input .= $v; } }
            $this->renderer->setStatus($prompt.$input);
            $this->renderer->draw();
        }
        $this->renderer->setStatus('');
        return $input;
    }

	private function filePrompt(string $cwd, string $initial = ''): ?string {
		// Emacs-style prompt: absolute path in minibuffer, Tab to complete, double-Tab to list, Alt+Backspace deletes previous "word"
		$dir = realpath($cwd) ?: ($cwd ?: '/');
		$input = $initial !== '' ? $initial : rtrim($dir, '/').'/';
		$showList = false; $listAll = []; $baseDir = $dir; $prefix = '';
		$listDir = $dir; // actual directory from which the list is generated
		$selIndex = 0; $scroll = 0; $listAll = [];
		$lastWasTab = false; $escCount = 0;
		// State to optimize list redraw
		$prevSelIndex = 0; $prevScroll = 0; $prevRows = 0; $prevColsCount = 0; $prevStartRow = 0; $prevColWidth = 0;
		// On start, show the list immediately (as if double-Tab)
		$showList = true;
		$in = $input;
		$baseDir = ($in !== '' && ($in[0] === '/' || $in[0] === '~')) ? '' : $dir;
		if ($in !== '' && $in[0] === '~') { $baseDir = getenv('HOME') ?: '/'; $in = substr($in,1); }
		$slash = strrpos($in, '/');
		if ($slash !== false) {
			$scanDir = ($input[0] === '/' || $input[0] === '~') ? substr($in,0,$slash) : rtrim($baseDir,'/').'/'.substr($in,0,$slash);
			$prefix = substr($in, $slash+1);
		} else {
			$scanDir = ($baseDir === '' ? '/' : $baseDir);
			$prefix = $in;
		}
		if ($scanDir === '') { $scanDir = '/'; }
		$cands = @scandir($scanDir) ?: [];
		$cands = array_values(array_filter($cands, function($e){ return $e !== '.'; }));
		usort($cands, function($a,$b) use ($scanDir){
			$da = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$a);
			$db = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$b);
			if ($da === $db) return strcmp($a,$b);
			return $da ? -1 : 1;
		});
		$matches = array_values(array_filter($cands, function($e) use ($prefix){ return $prefix === '' || strpos($e, $prefix) === 0; }));
		$listAll = array_map(function($e) use ($scanDir){ return $e.(is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$e) ? '/' : ''); }, $matches ?: $cands);
		$listDir = $scanDir;
		$selIndex = 0; $scroll = 0;
		while (true) {
			$this->renderer->setStatus('Find file: '.$input);
			$this->renderer->draw();
            // If the list is visible, keep it in sync with the current minibuffer input:
            // recompute the directory and the filtered candidates on every keypress.
            if ($showList) {
                $in = $input;
                $scanBase = ($in !== '' && ($in[0] === '/' || $in[0] === '~')) ? '' : $dir;
                if ($in !== '' && $in[0] === '~') {
                    $scanBase = getenv('HOME') ?: '/';
                    $in = substr($in, 1);
                }
                $slash = strrpos($in, '/');
                if ($slash !== false) {
                    $scanDir = ($input[0] === '/' || $input[0] === '~')
                        ? substr($in, 0, $slash)
                        : rtrim($scanBase, '/').'/'.substr($in, 0, $slash);
                    $prefix = substr($in, $slash+1);
                } else {
                    $scanDir = ($scanBase === '' ? '/' : $scanBase);
                    $prefix = $in;
                }
                if ($scanDir === '') { $scanDir = '/'; }
                $cands = @scandir($scanDir) ?: [];
                $cands = array_values(array_filter($cands, function($e){ return $e !== '.'; }));
                usort($cands, function($a,$b) use ($scanDir){
                    $da = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$a);
                    $db = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$b);
                    if ($da === $db) return strcmp($a,$b);
                    return $da ? -1 : 1;
                });
                $matches = array_values(array_filter($cands, function($e) use ($prefix){ return $prefix === '' || strpos($e, $prefix) === 0; }));
                $listAll = array_map(function($e) use ($scanDir){ return $e.(is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$e) ? '/' : ''); }, $matches ?: $cands);
                $listDir = $scanDir;
                if ($selIndex >= count($listAll)) {
                    $selIndex = max(0, count($listAll)-1);
                }
                // Force a full redraw of the list on next pass to avoid stale rows / duplicates
                $prevRows = 0;
                $prevColsCount = 0;
                $prevStartRow = 0;
                $prevColWidth = 0;
                $prevScroll = 0;
                $prevSelIndex = $selIndex;
            }
			// Draw multi-column list with scrolling (double-Tab)
			if ($showList) {
				$rows = max(8, min($this->term->rows - 2, intdiv($this->term->rows - 1, 2)));
				// Use the full area up to the penultimate line (last line is the minibuffer/status bar)
				$startRow = $this->term->rows - $rows;
				// Calculate widths and number of columns
				$maxLen = 0; foreach ($listAll as $nm) { $maxLen = max($maxLen, strlen($nm)); }
				$minCol = 12; $maxCol = 40;
				$colBase = max($minCol, min($maxCol, $maxLen + 2));
				$colsCount = max(1, intdiv($this->term->cols, $colBase));
				$colWidth = max(1, intdiv($this->term->cols, max(1,$colsCount)));
				$pageSize = $rows * $colsCount;
				// Ensure the selected element is inside the visible page
				if ($selIndex < $scroll) { $scroll = intdiv($selIndex, $pageSize) * $pageSize; }
				if ($selIndex >= $scroll + $pageSize) { $scroll = intdiv($selIndex, $pageSize) * $pageSize; }
				$layoutChanged = ($prevRows !== $rows || $prevColsCount !== $colsCount || $prevStartRow !== $startRow || $prevColWidth !== $colWidth || $prevScroll !== $scroll);
				if ($layoutChanged || $prevRows === 0) {
					// Full redraw: separator + all rows
					$listOut = Ansi::hideCursor();
					// Separator bar (modeline style) above the list
					$w = $this->activeWin(); $buf = $this->wins[$this->active]->buffer;
					$status = ($buf->dirty ? '*' : '-') . ' ' . ($buf->filePath !== '' ? $buf->filePath : '[No Name]');
					$percent = (int)round((($w->cursorRow+1) / max(1, $buf->lineCount())) * 100);
					$pos = 'L '.($w->cursorRow+1).', C '.($w->cursorCol+1).' ('.$percent.'%)';
					$left = $status.'  '.$pos; $right = ''; $space = max(0, $this->term->cols - strlen($left) - strlen($right));
					$sepBar = Ansi::color(Palette::activeStatus()).str_pad($left, $this->term->cols - strlen($right) - $space, ' ').str_repeat(' ', $space).$right.Ansi::reset();
					$listOut .= Ansi::move($startRow-1, 1).Ansi::clearLine().$sepBar;
					for ($r=0; $r<$rows; $r++) {
						$lineStr = '';
						for ($c=0; $c<$colsCount; $c++) {
							$idx = $scroll + $c*$rows + $r;
							$label = $listAll[$idx] ?? '';
							$isSel = ($idx === $selIndex);
							$cell = str_pad($label, max(0, $colWidth));
							$lineStr .= ($isSel ? Ansi::color(Palette::selection()) : '').$cell.($isSel ? Ansi::reset() : '');
						}
						$listOut .= Ansi::move($startRow + $r, 1).Ansi::clearLine().$lineStr;
					}
					// Restore editor cursor position (renderer has already computed window sizes)
					$cur = $this->activeWin();
					$cur->clampCursor($cur->buffer);
					$cur->ensureCursorVisible($cur->buffer);
					$cursorRowOnScreen = $cur->topRow + ($cur->cursorRow - $cur->scrollTop);
					$cursorColOnScreen = 1 + max(0, $cur->cursorCol - $cur->hscroll);
					$listOut .= Ansi::move($cursorRowOnScreen, $cursorColOnScreen).Ansi::showCursor();
					fwrite(STDOUT, $listOut);
					$prevRows = $rows; $prevColsCount = $colsCount; $prevStartRow = $startRow; $prevColWidth = $colWidth; $prevScroll = $scroll; $prevSelIndex = $selIndex;
				} else {
					// Partial redraw: only the row with old and new selection
					$oldRow = ($prevSelIndex - $scroll) % $rows;
					$newRow = ($selIndex - $scroll) % $rows;
					$targets = array_unique(array_filter([$oldRow, $newRow], function($r) use ($rows){ return $r>=0 && $r<$rows; }));
					$listOut = Ansi::hideCursor();
					foreach ($targets as $r) {
						$lineStr = '';
						for ($c=0; $c<$colsCount; $c++) {
							$idx = $scroll + $c*$rows + $r;
							$label = $listAll[$idx] ?? '';
							$isSel = ($idx === $selIndex);
							$cell = str_pad($label, max(0, $colWidth));
							$lineStr .= ($isSel ? Ansi::color(Palette::selection()) : '').$cell.($isSel ? Ansi::reset() : '');
						}
						$listOut .= Ansi::move($startRow + $r, 1).Ansi::clearLine().$lineStr;
					}
					// Restore cursor to editor position
					$cur = $this->activeWin();
					$cur->clampCursor($cur->buffer);
					$cur->ensureCursorVisible($cur->buffer);
					$cursorRowOnScreen = $cur->topRow + ($cur->cursorRow - $cur->scrollTop);
					$cursorColOnScreen = 1 + max(0, $cur->cursorCol - $cur->hscroll);
					$listOut .= Ansi::move($cursorRowOnScreen, $cursorColOnScreen).Ansi::showCursor();
					fwrite(STDOUT, $listOut);
					$prevSelIndex = $selIndex;
				}
			} else {
				// If the list is hidden, clear the list area and the separator line
				$rows = max(8, min($this->term->rows - 2, intdiv($this->term->rows - 1, 2)));
				$startRow = $this->term->rows - $rows;
				$listOut = Ansi::hideCursor();
				for ($clr=$startRow-1; $clr<=$this->term->rows-1; $clr++) {
					$listOut .= Ansi::move($clr, 1).Ansi::clearLine();
				}
				$cur = $this->activeWin();
				$cur->clampCursor($cur->buffer);
				$cur->ensureCursorVisible($cur->buffer);
				$cursorRowOnScreen = $cur->topRow + ($cur->cursorRow - $cur->scrollTop);
				$cursorColOnScreen = 1 + max(0, $cur->cursorCol - $cur->hscroll);
				$listOut .= Ansi::move($cursorRowOnScreen, $cursorColOnScreen).Ansi::showCursor();
				fwrite(STDOUT, $listOut);
			}

			$k = (new Input())->readKey();
			[$t,$v] = $k; $handled = false;
			// Handle resume from background while inside file prompt
			if ($t === Keys::SPECIAL && $v === 'sigcont') {
				$GLOBALS['__pemacs_sigcont'] = false;
				$this->term->rawSafe();
				fwrite(STDOUT, Ansi::clear());
				@stream_set_blocking(STDIN, false);
				$this->renderer->invalidate();
				$this->renderer->setWindows($this->wins, $this->active);
				$this->renderer->draw();
				continue;
			}
			if ($t === Keys::SPECIAL && $v === 'enter') {
				$path = '';
				if ($showList && isset($listAll[$selIndex])) {
					$pick = $listAll[$selIndex];
					$path = ($listDir === '/' ? '/' : rtrim($listDir,'/').'/').rtrim($pick,'/');
				} else {
					$path = $input;
				}
				if ($path === '') { $lastWasTab = false; continue; }
				// expand tilde
				if ($path[0] === '~') { $home = getenv('HOME') ?: '/'; $path = $home.substr($path,1); }
				if (is_dir($path)) {
					$dir = realpath($path) ?: $path;
					$input = rtrim($dir,'/').'/';
					$baseDir = $dir;
					// Rebuild the list immediately in the new directory (like double-Tab)
					$scanDir = $dir;
					$cands = @scandir($scanDir) ?: [];
					$cands = array_values(array_filter($cands, function($e){ return $e !== '.'; }));
					usort($cands, function($a,$b) use ($scanDir){
						$da = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$a);
						$db = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$b);
						if ($da === $db) return strcmp($a,$b);
						return $da ? -1 : 1;
					});
					$listAll = array_map(function($e) use ($scanDir){ return $e.(is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$e) ? '/' : ''); }, $cands);
					$listDir = $scanDir;
					$selIndex = 0; $scroll = 0; $showList = true; $lastWasTab = false;
					continue;
				}
				$this->renderer->setStatus('');
				return $path;
			}
			if ($t === Keys::CTRL && $v === 'g') { $this->renderer->setStatus(''); return null; }
			// Exit find-file with a single ESC (Emacs-like)
			if ($t === Keys::ASCII && $v === "\x1b") { $this->renderer->setStatus(''); return null; }
			// Backspace deletes last typed char (does not exit)
			if ($t === Keys::SPECIAL && $v === 'backspace') {
				if ($input !== '') {
					$input = substr($input, 0, -1);
					$lastWasTab = false;
					continue;
				}
				// If there's nothing to delete, exit (same as ESC)
				$this->renderer->setStatus('');
				return null;
			}
			if ($t === Keys::ALT && $v === 'backspace') {
				// Delete previous "word" (up to previous slash)
				$trim = rtrim($input, '/');
				$slash = strrpos($trim, '/');
				if ($slash === false) { $input = ''; }
				else { $input = substr($input, 0, $slash+1); }
				$showList = false; $lastWasTab = false; $handled = true;
			}
			if (!$handled && $t === Keys::ASCII && $v !== '') {
				$input .= $v; $lastWasTab = false; $handled = true;
			}
			if ($t === Keys::SPECIAL && $v === 'tab') {
				$wasShowing = $showList;
				// Calculate baseDir and prefix based on input
				$in = $input;
				$baseDir = ($in !== '' && ($in[0] === '/' || $in[0] === '~')) ? '' : $dir;
				if ($in !== '' && $in[0] === '~') { $baseDir = getenv('HOME') ?: '/'; $in = substr($in,1); }
				$slash = strrpos($in, '/');
				if ($slash !== false) {
					$baseDir = ($input[0] === '/' || $input[0] === '~') ? substr($in,0,$slash) : rtrim($baseDir,'/').'/'.substr($in,0,$slash);
					$prefix = substr($in, $slash+1);
				} else { $prefix = $in; $baseDir = ($baseDir === '' ? '/' : $baseDir); }
				$scanDir = $baseDir;
				if ($scanDir === '') { $scanDir = '/'; }
				$cands = @scandir($scanDir) ?: [];
				$cands = array_values(array_filter($cands, function($e){ return $e !== '.'; }));
				usort($cands, function($a,$b) use ($scanDir){
					$da = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$a);
					$db = is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$b);
					if ($da === $db) return strcmp($a,$b);
					return $da ? -1 : 1;
				});
				$matches = array_values(array_filter($cands, function($e) use ($prefix){ return $prefix === '' || strpos($e, $prefix) === 0; }));
				// If there is a single match, complete immediately
				if (count($matches) === 1) {
					$single = $matches[0];
					$head = ($slash !== false) ? substr($input, 0, strrpos($input,'/')+1) : '';
					$input = $head.$single;
					$abs = (($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$single);
					if (is_dir($abs)) { $input .= '/'; }
					$showList = $wasShowing; $lastWasTab = false;
				} else if (count($matches) > 1) {
					// Try to extend to the longest common prefix
					$lcp = '';
					for ($i=0; ; $i++) {
						$ch = null; $same = true;
						foreach ($matches as $m) {
							if ($i >= strlen($m)) { $same = false; break; }
							if ($ch === null) { $ch = $m[$i]; }
							elseif ($m[$i] !== $ch) { $same = false; break; }
						}
						if (!$same) break; $lcp .= $ch;
					}
					if ($lcp !== '' && $lcp !== $prefix) {
						$head = ($slash !== false) ? substr($input, 0, strrpos($input,'/')+1) : '';
						$input = $head.$lcp;
						$showList = $wasShowing; $lastWasTab = false;
					} else {
						// Double-Tab: show the list
						if ($lastWasTab) {
						$showList = true;
						$listAll = array_map(function($e) use ($scanDir){ return $e.(is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$e) ? '/' : ''); }, $matches);
						$selIndex = 0; $scroll = 0; $listDir = $scanDir;
						} else {
							$showList = $wasShowing; // do not hide if already visible
						}
						$lastWasTab = !$showList ? true : false; // stays true when we didn't show
					}
				} else {
					// No match: on double-Tab show the current directory
					if ($lastWasTab) {
						$showList = true;
						$listAll = array_map(function($e) use ($scanDir){ return $e.(is_dir(($scanDir==='/'?'/':rtrim($scanDir,'/').'/').$e) ? '/' : ''); }, $cands);
						$selIndex = 0; $scroll = 0; $listDir = $scanDir;
					} else { $showList = $wasShowing; }
					$lastWasTab = !$showList ? true : false;
				}
				continue;
			}
			if ($showList) {
				if ($t === Keys::ARROW) {
					if ($v === 'down') { $selIndex = min(max(0,count($listAll)-1), $selIndex + 1); }
					if ($v === 'up') { $selIndex = max(0, $selIndex - 1); }
					if ($v === 'right') { $selIndex = min(max(0,count($listAll)-1), $selIndex + $rows); }
					if ($v === 'left') { $selIndex = max(0, $selIndex - $rows); }
					continue;
				}
				if ($t === Keys::SPECIAL && ($v === 'pgdn' || $v === 'pgup')) {
					$rows = max(8, min($this->term->rows - 2, intdiv($this->term->rows - 1, 2)));
					$maxLen = 0; foreach ($listAll as $nm) { $maxLen = max($maxLen, strlen($nm)); }
					$colBase = max(12, min(40, $maxLen + 2));
					$colsCount = max(1, intdiv($this->term->cols, $colBase));
					$pageSize = $rows * $colsCount;
					if ($v === 'pgdn') { $selIndex = min(max(0,count($listAll)-1), $selIndex + $pageSize); }
					else { $selIndex = max(0, $selIndex - $pageSize); }
					continue;
				}
			}
			$lastWasTab = false;
		}
	}

    private function findFile(): void {
        $cwd = ($this->buf->filePath ?? '') !== '' ? dirname($this->buf->filePath) : (getcwd() ?: '.');
        $path = $this->filePrompt($cwd, '');
        if ($path === null) { $this->renderer->setStatus(''); $this->renderer->invalidate(); $this->renderer->draw(); return; }
        if (is_dir($path)) { $this->renderer->setStatus('Is a directory'); return; }
        if (!is_file($path)) {
            $parent = dirname($path);
            if (!is_dir($parent)) { $this->setStatus('Directory not found'); return; }
            @touch($path);
        }
        // Load into buffer
        // Replace buffer only in the active window (pane independence)
        $this->wins[$this->active]->buffer = new Buffer($path);
        $this->buf = $this->wins[$this->active]->buffer;
        // Reset window
        $w=$this->activeWin(); $w->cursorRow=0; $w->cursorCol=0; $w->scrollTop=0; $w->hscroll=0;
        $this->snapshot();
        $this->renderer->setWindows($this->wins, $this->active);
        $this->setStatus('Opened '.$path);
        $this->renderer->invalidate();
        $this->renderer->draw();
    }

    private function saveFile(): void {
        if ($this->buf->save()) { $this->setStatus('Saved '); $this->renderer->setTopOverlay('Saved '); $this->overlayDismissOnKey = true; $this->renderer->draw(); }
        else { $this->setStatus('Save error '); }
    }

    private function maybeQuit() {
        if ($this->buf->dirty) {
            $ans = $this->yesNoPrompt('Modified buffer. Quit without saving? (y/n) ');
            if (!$ans) return null;
        }
        return 'quit';
    }

    private function yesNoPrompt(string $msg): bool {
        $this->renderer->setStatus($msg);
        $this->renderer->draw();
        while (true) {
            $k = (new Input())->readKey();
            if ($k[0] === Keys::ASCII) {
                if ($k[1] === 'y' || $k[1] === 'Y') { $this->renderer->setStatus(''); return true; }
                if ($k[1] === 'n' || $k[1] === 'N') { $this->renderer->setStatus(''); return false; }
            }
        }
    }

    // Incremental search (Ctrl+s): search bar in status bar, live updates; pressing Ctrl+s again goes to next match
    private function incrementalSearch(string $initialQuery = ''): void {
        $query = $initialQuery;
        $startPos = [$this->activeWin()->cursorRow, $this->activeWin()->cursorCol];
        $originRow = $startPos[0];
        $originCol = $startPos[1];
        $this->renderer->setStatus('I-Search: ' . $query);
        $this->renderer->draw();
        if ($query !== '') {
            // show the existing query and move to the first match from origin
            $this->activeWin()->cursorRow = $originRow; $this->activeWin()->cursorCol = $originCol;
            $this->searchNext($query, false, true);
        }
        $postAction = null; // callable-like via string flag
        while (true) {
            $k = (new Input())->readKey();
            [$t,$v] = $k;
            if (($t === Keys::SPECIAL && $v === 'enter') || ($t === Keys::ASCII && $v === "\x1b")) { break; }
            if ($t === Keys::CTRL && $v === 'g') { // abort
                $w=$this->activeWin(); $w->cursorRow=$startPos[0]; $w->cursorCol=$startPos[1]; $this->renderer->setStatus(''); return; }
            // Exit on movement keys and execute them after leaving search
            if ($t === Keys::ARROW) { $postAction = ['type'=>'arrow','dir'=>$v]; break; }
            if ($t === Keys::CTRL && $v === 'a') { $postAction = ['type'=>'cmd','name'=>'bol']; break; }
            if ($t === Keys::CTRL && $v === 'e') { $postAction = ['type'=>'cmd','name'=>'eol']; break; }
            if ($t === Keys::ALT && ($v === 'b' || $v === 'B')) { $postAction = ['type'=>'cmd','name'=>'backwardWord']; break; }
            if ($t === Keys::ALT && ($v === 'f' || $v === 'F')) { $postAction = ['type'=>'cmd','name'=>'forwardWord']; break; }
            if ($t === Keys::CTRL && $v === 's') {
                // If the query is empty and a previous search exists, auto-insert and search immediately
                if ($query === '' && ($this->lastSearch ?? '') !== '') {
                    $query = $this->lastSearch;
                    $this->renderer->setStatus('I-Search: '.$query);
                    $this->renderer->draw();
                    // restart from origin and find the first match
                    $this->activeWin()->cursorRow = $originRow; $this->activeWin()->cursorCol = $originCol;
                    $this->searchNext($query, false, true);
                    continue;
                }
                // Otherwise, repeat search moving to the next match
                $this->searchNext($query, true, true);
                continue;
            }
            if ($t === Keys::SPECIAL && $v === 'backspace') { $query = substr($query,0,-1); }
            elseif ($t === Keys::ASCII && $v !== '') { $query .= $v; }
            $this->renderer->setStatus('I-Search: '.$query);
            $this->renderer->draw();
            // after each query change, search from the original origin position
            $this->activeWin()->cursorRow = $originRow; $this->activeWin()->cursorCol = $originCol;
            $this->searchNext($query, false, true);
        }
        $this->lastSearch = $query;
        $this->lastSearchRow = $this->activeWin()->cursorRow;
        $this->lastSearchCol = max(0, $this->activeWin()->cursorCol - strlen($query));
        $this->activeWin()->hasMark = false; $this->renderer->setStatus('');
        // Execute any queued movement after exiting search
        if ($postAction !== null) {
            if ($postAction['type'] === 'arrow') { $this->moveCursor($postAction['dir']); }
            else if ($postAction['type'] === 'cmd') {
                if ($postAction['name'] === 'bol') { $this->moveBeginningOfLine(); }
                else if ($postAction['name'] === 'eol') { $this->moveEndOfLine(); }
                else if ($postAction['name'] === 'backwardWord') { $this->backwardWord(); }
                else if ($postAction['name'] === 'forwardWord') { $this->forwardWord(); }
            }
        }
    }

    private function searchNext(string $query, bool $fromAfter, bool $select=false): void {
        if ($query === '') return;
        $w=$this->activeWin(); $n = $this->buf->lineCount();
        $startRow = $w->cursorRow; $startCol = $w->cursorCol + ($fromAfter ? 1 : 0);
        $q = strtolower($query);
        for ($pass=0; $pass<2; $pass++) {
            for ($r = ($pass===0 ? $startRow : 0); $r < $n; $r++) {
                $line = $this->buf->lines[$r]; $hay = strtolower($line);
                $offset = ($pass===0 && $r===$startRow) ? max(0,$startCol) : 0;
                $pos = strpos($hay, $q, $offset);
                if ($pos !== false) {
                    if ($select) { $w->hasMark = true; $w->markRow = $r; $w->markCol = $pos; $w->cursorRow = $r; $w->cursorCol = $pos + strlen($query); }
                    else { $w->cursorRow = $r; $w->cursorCol = $pos; }
                    // Center view around the new cursor position (like Ctrl+l)
                    $this->recenter();
                    return;
                }
            }
        }
        $this->renderer->setStatus('I-Search: not found');
    }

    private function splitHorizontal(): void {
        if (count($this->wins) === 1) {
            $this->wins[] = new Window(1, 1, $this->term->cols, $this->wins[$this->active]->buffer);
        }
        $this->setStatus('Split');
    }

    private function otherWindow(): void {
        if (count($this->wins) > 1) { $this->active = 1 - $this->active; $this->buf = $this->wins[$this->active]->buffer; }
    }

    // Ctrl+1: solo il pane attuale
    private function makeOnlyThisWindow(): void {
        if (count($this->wins) > 1) {
            $this->wins = [$this->wins[$this->active]];
            $this->active = 0;
            $this->buf = $this->wins[0]->buffer;
        }
    }

    // Ctrl+0: close current pane
    private function closeCurrentWindow(): void {
        if (count($this->wins) > 1) {
            array_splice($this->wins, $this->active, 1);
            $this->active = 0;
            $this->buf = $this->wins[0]->buffer;
        }
    }
}

// ---- Bootstrap ----
// Supporto a -q (quit immediately after loading)
$args = $argv; array_shift($args);
$quitImmediately = false; $fileArg = '';
foreach ($args as $a) { if ($a === '-q') { $quitImmediately = true; } else if ($fileArg === '') { $fileArg = $a; } }
$term = new Terminal();
$buffer = new Buffer($fileArg);
$editor = new Editor($term, $buffer);
// Signal handling: ensure clean restore on SIGINT/SIGTERM/SIGHUP/SIGQUIT
if (function_exists('pcntl_signal')) {
    $handler = function(int $sig) use ($term) {
        $term->restore();
        fwrite(STDOUT, Ansi::clear()); fflush(STDOUT);
        // Exit with code indicating signal
        exit(128 + $sig);
    };
    @pcntl_signal(SIGINT, $handler);
    @pcntl_signal(SIGTERM, $handler);
    @pcntl_signal(SIGHUP, $handler);
    @pcntl_signal(SIGQUIT, $handler);
    // Ctrl+Z support: on SIGTSTP restore terminal then actually suspend; on SIGCONT re-enter raw and redraw
    $tstpHandler = function(int $sig) use ($term) {
        $term->restore();
        // Pass to default action (suspension): reset default handler and re-send signal
        if (function_exists('pcntl_signal')) { @pcntl_signal(SIGTSTP, SIG_DFL); }
        if (function_exists('posix_kill')) { @posix_kill(getmypid(), SIGTSTP); }
        else { @shell_exec('kill -TSTP '.getmypid()); }
    };
    $GLOBALS['__pemacs_tstp_handler'] = $tstpHandler;
    @pcntl_signal(SIGTSTP, $tstpHandler);
    $contHandler = function(int $sig) use ($term) {
        // Just signal; re-initialization raw will happen in main loop
        // Reinstall handler SIGTSTP
        if (function_exists('pcntl_signal') && isset($GLOBALS['__pemacs_tstp_handler'])) {
            @pcntl_signal(SIGTSTP, $GLOBALS['__pemacs_tstp_handler']);
        }
        // Signal to main loop to invalidate and redraw completely
        $GLOBALS['__pemacs_sigcont'] = true;
        // Ensure reading doesn't get blocked
        @stream_set_blocking(STDIN, false);
    };
    @pcntl_signal(SIGCONT, $contHandler);
    // Async handling: no need to call pcntl_signal_dispatch in the loop
    if (function_exists('pcntl_async_signals')) { @pcntl_async_signals(true); }
}
if ($quitImmediately) {
    $term->restore();
    fwrite(STDOUT, Ansi::clear()); fflush(STDOUT);
} else {
    $editor->run();
    // Restore terminal and explicitly clear the screen
    $term->restore();
    fwrite(STDOUT, Ansi::clear()); fflush(STDOUT);
}



