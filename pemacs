#!/usr/bin/env php
<?php
// PEMacs - Pure PHP TTY editor inspired by Emacs keybindings
// Requirements: PHP 7.4+, Linux TTY. No external PHP extensions. Uses stty + ANSI.

declare(strict_types=1);
// Evita che eventuali warning rovinino lo schermo del terminale
@ini_set('display_errors', '0');

// ---- Utility: ANSI helpers ----
class Ansi {
    public const ESC = "\033";
    public static function hideCursor(): string { return self::ESC.'[?25l'; }
    public static function showCursor(): string { return self::ESC.'[?25h'; }
    public static function clear(): string { return self::ESC.'[2J'.self::ESC.'[H'; }
    public static function move(int $row, int $col): string { return self::ESC.'['.$row.';'.$col.'H'; }
    public static function color(string $codes): string { return self::ESC.'['.$codes.'m'; }
    public static function reset(): string { return self::ESC.'[0m'; }
    public static function clearLine(): string { return self::ESC.'[2K'; }
}

// ---- Terminal control ----
final class Terminal {
    private string $sttySaved;
    public int $rows = 24;
    public int $cols = 80;

    public function __construct() {
        $this->sttySaved = rtrim(shell_exec('stty -g') ?? '');
        register_shutdown_function(function () {
            $this->restore();
        });
        $this->raw();
        $this->querySize();
        stream_set_blocking(STDIN, false);
    }

    public function raw(): void {
        // Disabilita XON/XOFF (Ctrl+S / Ctrl+Q) e imposta modalità raw
        shell_exec('stty -ixon -icanon -echo -isig min 1 time 0');
        // Entra nello schermo alternativo in modo compatibile
        $smcup = rtrim(shell_exec('tput smcup 2>/dev/null') ?? '');
        if ($smcup !== '') { fwrite(STDOUT, $smcup); }
        else { fwrite(STDOUT, Ansi::ESC.'[?1049h'); }
        // Pulisci e mostra il cursore
        fwrite(STDOUT, Ansi::clear().Ansi::reset().Ansi::showCursor());
    }

    public function restore(): void {
        // Reset integrale: ripristina stty e resetta schermo e scrollback
        if ($this->sttySaved !== '') { shell_exec('stty '.$this->sttySaved); }
        // Torna allo schermo principale in modo compatibile
        $rmcup = rtrim(shell_exec('tput rmcup 2>/dev/null') ?? '');
        if ($rmcup !== '') { fwrite(STDOUT, $rmcup); }
        else { fwrite(STDOUT, Ansi::ESC.'[?1049l'); }
        // Pulisci visibile + scrollback, porta il cursore in home, mostra cursore e resetta colori
        fwrite(STDOUT, "\033[3J\033[2J\033[H\033[0m\033[?25h");
        fflush(STDOUT);
    }

    public function querySize(): void {
        $out = trim(shell_exec('stty size') ?? '');
        if ($out !== '') {
            [$r, $c] = array_map('intval', preg_split('/\s+/', $out));
            if ($r > 0 && $c > 0) { $this->rows = $r; $this->cols = $c; }
        }
    }
}

// ---- Data model ----
final class Buffer {
    /** @var string[] */
    public array $lines;
    public string $filePath;
    public bool $dirty = false;

    public function __construct(string $filePath, ?string $content = null) {
        $this->filePath = $filePath;
        if ($content === null && $filePath !== '') {
            $content = is_file($filePath) ? (file_get_contents($filePath) ?: '') : '';
        }
        $content = $content ?? '';
        $content = str_replace(["\r\n", "\r"], "\n", $content);
        $this->lines = explode("\n", $content);
    }

    public function lineCount(): int { return count($this->lines); }

    public function ensureLine(int $row): void {
        while ($row >= count($this->lines)) { $this->lines[] = ''; }
    }

    public function save(): bool {
        $target = $this->filePath !== '' ? $this->filePath : 'untitled.txt';
        $tmp = $target.'.tmp';
        $data = implode("\n", $this->lines);
        if (@file_put_contents($tmp, $data) === false) { return false; }
        if (!@rename($tmp, $target)) { return false; }
        $this->dirty = false;
        $this->filePath = $target;
        return true;
    }

    public function loadFile(string $path): void {
        $this->filePath = $path;
        $content = is_file($path) ? (file_get_contents($path) ?: '') : '';
        $content = str_replace(["\r\n", "\r"], "\n", $content);
        $this->lines = explode("\n", $content);
        $this->dirty = false;
    }
}

final class Window {
    public int $cursorRow = 0; // 0-based in buffer
    public int $cursorCol = 0; // 0-based in chars
    public int $scrollTop = 0; // first buffer row visible
    public int $hscroll = 0;   // first buffer column visible (horizontal)
    public int $topRow = 1;    // 1-based terminal position
    public int $height = 0;    // lines available for text (excl status)
    public int $width = 0;
    public bool $hasMark = false;
    public int $markRow = 0;   // selection anchor
    public int $markCol = 0;

    public function __construct(int $topRow, int $height, int $width) {
        $this->topRow = $topRow;
        $this->height = max(1, $height);
        $this->width = $width;
    }

    public function clampCursor(Buffer $buf): void {
        $this->cursorRow = max(0, min($buf->lineCount()-1, $this->cursorRow));
        $line = $buf->lines[$this->cursorRow] ?? '';
        $this->cursorCol = max(0, min(strlen($line), $this->cursorCol));
    }

    public function ensureCursorVisible(Buffer $buf): void {
        if ($this->cursorRow < $this->scrollTop) { $this->scrollTop = $this->cursorRow; }
        if ($this->cursorRow >= $this->scrollTop + ($this->height-1)) {
            $this->scrollTop = $this->cursorRow - ($this->height-2);
        }
        if ($this->scrollTop < 0) { $this->scrollTop = 0; }
        // Horizontal
        if ($this->cursorCol < $this->hscroll) { $this->hscroll = $this->cursorCol; }
        if ($this->cursorCol >= $this->hscroll + max(1, $this->width-1)) {
            $this->hscroll = max(0, $this->cursorCol - max(1, $this->width-10));
        }
    }

    public function selectionBounds(): ?array {
        if (!$this->hasMark) { return null; }
        $a = [$this->markRow, $this->markCol];
        $b = [$this->cursorRow, $this->cursorCol];
        if ($a === $b) { return null; }
        // Normalize
        if ($b[0] < $a[0] || ($b[0] === $a[0] && $b[1] < $a[1])) { [$a, $b] = [$b, $a]; }
        return [$a, $b];
    }
}

// ---- Renderer and Highlighter ----
final class Palette {
    // Colors inspired by screenshot
    // Emacs-like: base fg white on black, comments gray, strings yellow, keywords bright magenta, variables cyan
    public static function base(): string { return '37;40'; }
    public static function comment(): string { return '90'; }
    // Strings bright red per richiesta
    public static function string(): string { return '91'; }
    public static function keyword(): string { return '95'; }
    public static function variable(): string { return '33'; }
    public static function number(): string { return '94'; }
    public static function htmlTag(): string { return '35'; }
    public static function htmlAttr(): string { return '36'; }
    public static function status(): string { return '30;47'; }
    public static function activeStatus(): string { return '30;46'; }
    // Inversione video per mostrare il testo selezionato
    public static function selection(): string { return '7'; }
    // Function/method names: blu brillante
    public static function functionName(): string { return '94'; }
    // Class names verdino
    public static function className(): string { return '92'; }
    // Proprietà oggetto dopo '->' marroncino (giallo tenue)
    public static function propertyName(): string { return '33'; }
    // Costanti booleane
    public static function constTrue(): string { return '92'; }
    public static function constFalse(): string { return '96'; }
}

final class Highlighter {
    public static array $phpKeywords = [
        'abstract','and','array','as','break','callable','case','catch','class','clone','const','continue','declare','default','do','else','elseif','enddeclare','endfor','endforeach','endif','endswitch','endwhile','extends','final','finally','fn','for','foreach','function','global','goto','if','implements','include','include_once','instanceof','insteadof','interface','isset','list','match','namespace','new','or','print','private','protected','public','require','require_once','return','static','switch','throw','trait','try','unset','use','var','while','xor','yield'
    ];
    public static array $jsKeywords = [
        'break','case','catch','class','const','continue','debugger','default','delete','do','else','export','extends','finally','for','function','if','import','in','instanceof','let','new','return','super','switch','this','throw','try','typeof','var','void','while','with','yield'
    ];

    public static function colorize(string $line): string {
        $colored = '';
        $i = 0; $len = strlen($line);
        while ($i < $len) {
            $ch = $line[$i];
            // Class declaration (case-insensitive): highlight keyword and class name
            if (preg_match('/^([cC][lL][aA][sS][sS])\s+([a-zA-Z_][a-zA-Z0-9_]*)/', substr($line, $i), $mc)) {
                $kw = $mc[1]; $name = $mc[2];
                $colored .= Ansi::color(Palette::keyword()).$kw.Ansi::reset().' ';
                $colored .= Ansi::color(Palette::className()).$name.Ansi::reset();
                $i += strlen($kw) + 1 + strlen($name);
                continue;
            }
            // Object access: ->property or ->method()
            if ($ch === '-' && $i+1 < $len && $line[$i+1] === '>') {
                // include the arrow as-is
                $colored .= '->';
                $i += 2;
                // optional spaces then identifier
                if (preg_match('/^\s*([a-zA-Z_][a-zA-Z0-9_]*)/', substr($line, $i), $mm)) {
                    $match = $mm[0];
                    $name = $mm[1];
                    $spacesLen = strlen($match) - strlen($name);
                    if ($spacesLen > 0) { $colored .= substr($match, 0, $spacesLen); }
                    $i += strlen($match);
                    // lookahead for method call '('
                    $k = $i; while ($k < $len && $line[$k] === ' ') { $k++; }
                    if ($k < $len && $line[$k] === '(') {
                        // method: white
                        $colored .= Ansi::color(Palette::functionName()).$name.Ansi::reset();
                    } else {
                        // property: brownish
                        $colored .= Ansi::color(Palette::propertyName()).$name.Ansi::reset();
                    }
                    continue;
                }
            }
            // Function names (simple heuristic: identifier followed by '(' with no $ in front)
            if (preg_match('/^([a-zA-Z_][a-zA-Z0-9_]*)\s*\(/', substr($line, $i), $mf)) {
                $name = $mf[1];
                if ($i===0 || ($i>0 && $line[$i-1] !== '$')) {
                    $colored .= Ansi::color(Palette::functionName()).$name.Ansi::reset();
                    $i += strlen($name);
                    continue;
                }
            }
            // Strings
            if ($ch === '"' || $ch === "'") {
                [$tok, $end] = self::consumeString($line, $i, $ch);
                $colored .= Ansi::color(Palette::string()).$tok.Ansi::reset();
                $i = $end; continue;
            }
            // Line comment // or #
            if ($ch === '/' && $i+1 < $len && $line[$i+1] === '/') {
                $tok = substr($line, $i);
                $colored .= Ansi::color(Palette::comment()).$tok.Ansi::reset();
                break;
            }
            if ($ch === '#') {
                $tok = substr($line, $i);
                $colored .= Ansi::color(Palette::comment()).$tok.Ansi::reset();
                break;
            }
            // PHP inline open/close tags treated as plain
            if ($ch === '<' && substr($line, $i, 5) === '<?php') {
                $colored .= substr($line, $i, 5); $i += 5; continue;
            }
            if ($ch === '?' && substr($line, $i, 2) === '?>') {
                $colored .= '?>'; $i += 2; continue;
            }
            // HTML tag
            if ($ch === '<') {
                if (preg_match('/^<\/?[a-zA-Z0-9\-]+/', substr($line, $i), $m)) {
                    $tok = $m[0];
                    $colored .= Ansi::color(Palette::htmlTag()).$tok.Ansi::reset();
                    $i += strlen($tok);
                    // Attributes
                    while ($i < $len && preg_match('/^\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*/', substr($line, $i), $ma)) {
                        $colored .= $ma[0];
                        $i += strlen($ma[0]);
                        if ($i < $len && $line[$i] === '=') {
                            $colored .= '='; $i++;
                            // Value
                            if ($i < $len && ($line[$i] === '"' || $line[$i] === "'")) {
                                [$sv, $end] = self::consumeString($line, $i, $line[$i]);
                                $colored .= Ansi::color(Palette::string()).$sv.Ansi::reset();
                                $i = $end;
                            }
                        }
                    }
                    // Closing '>' if present
                    if ($i < $len && ($line[$i] === '>' || ($line[$i] === '/' && $i+1 < $len && $line[$i+1] === '>'))) {
                        $close = ($line[$i] === '/') ? '/>' : '>';
                        $colored .= Ansi::color(Palette::htmlTag()).$close.Ansi::reset();
                        $i += strlen($close);
                    }
                    continue;
                }
            }
            // Numbers
            if (ctype_digit($ch)) {
                if (preg_match('/^\d+(?:\.\d+)?/', substr($line, $i), $m)) {
                    $colored .= Ansi::color(Palette::number()).$m[0].Ansi::reset();
                    $i += strlen($m[0]);
                    continue;
                }
            }
            // Variable $foo (marroncino)
            if ($ch === '$' && preg_match('/^\$[a-zA-Z_][a-zA-Z0-9_]*/', substr($line, $i), $m)) {
                $colored .= Ansi::color(Palette::variable()).$m[0].Ansi::reset();
                $i += strlen($m[0]);
                continue;
            }
            // Keywords (PHP/JS) e booleani true/false colorati
            if (preg_match('/^[a-zA-Z_][a-zA-Z0-9_]*/', substr($line, $i), $m)) {
                $w = $m[0];
                if ($w === 'true') { $colored .= Ansi::color(Palette::constTrue()).$w.Ansi::reset(); $i += strlen($w); continue; }
                if ($w === 'false') { $colored .= Ansi::color(Palette::constFalse()).$w.Ansi::reset(); $i += strlen($w); continue; }
                if (in_array($w, self::$phpKeywords, true) || in_array($w, self::$jsKeywords, true)) {
                    $colored .= Ansi::color(Palette::keyword()).$w.Ansi::reset();
                } else {
                    $colored .= $w;
                }
                $i += strlen($w);
                continue;
            }

            // Default char
            $colored .= $ch; $i++;
        }
        return $colored;
    }

    private static function consumeString(string $line, int $start, string $quote): array {
        $i = $start; $len = strlen($line);
        $buf = '';
        $buf .= $line[$i++];
        $escaped = false;
        while ($i < $len) {
            $ch = $line[$i++];
            $buf .= $ch;
            if ($escaped) { $escaped = false; continue; }
            if ($ch === '\\') { $escaped = true; continue; }
            if ($ch === $quote) { break; }
        }
        return [$buf, $i];
    }
}

final class Renderer {
    private Terminal $term;
    private Buffer $buf;
    /** @var Window[] */
    private array $windows;
    private int $activeIndex = 0;
    private string $statusMsg = '';
    /** @var array<int,string> righe renderizzate nell'ultimo frame (contenuto con SGR, senza movimenti) */
    private array $lastLineContent = [];
    /** @var array<int,?array{start:int,len:int,seg:string}> overlay selezione per riga schermo */
    private array $lastSelSeg = [];
    private string $lastStatusBar = '';

    public function __construct(Terminal $term, Buffer $buf, array $windows) {
        $this->term = $term; $this->buf = $buf; $this->windows = $windows;
    }

    public function setWindows(array $windows, int $activeIndex): void { $this->windows = $windows; $this->activeIndex = $activeIndex; }
    public function setStatus(string $msg): void { $this->statusMsg = $msg; }
    public function activeIndex(): int { return $this->activeIndex; }

    public function draw(): void {
        $this->term->querySize();
        $totalRows = $this->term->rows; $cols = $this->term->cols;
        // Recompute window sizes (split horizontal)
        if (count($this->windows) === 1) {
            $this->windows[0]->topRow = 1;
            $this->windows[0]->height = $totalRows - 1; // status bar
            $this->windows[0]->width = $cols;
        } else {
            $upper = $this->windows[0];
            $lower = $this->windows[1];
            $half = intdiv($totalRows - 1, 2);
            $upper->topRow = 1; $upper->height = max(1, $half-1); $upper->width = $cols;
            // linea separatrice
            $sepRow = 1 + $upper->height;
            $lower->topRow = $sepRow + 1; $lower->height = ($totalRows - 1) - $upper->height - 1; $lower->width = $cols;
            $this->windows = [$upper, $lower];
        }

        $out = Ansi::hideCursor();
        foreach ($this->windows as $wi => $w) {
            // Draw text area (differenziale per riga)
            for ($r = 0; $r < $w->height; $r++) {
                $screenRow = $w->topRow + $r;
                $bufRow = $w->scrollTop + $r;
                $line = $this->buf->lines[$bufRow] ?? '';
                $visual = str_replace("\t", ' ', $line);
                $colored = Highlighter::colorize($visual);
                $rendered = self::sliceAnsi($colored, $w->hscroll, $w->width);
                $content = Ansi::color(Palette::base()).$rendered.Ansi::reset();

                $updatedBase = false;
                $prev = $this->lastLineContent[$screenRow] ?? null;
                if ($prev !== $content) {
                    $out .= Ansi::move($screenRow, 1).Ansi::clearLine().$content;
                    $this->lastLineContent[$screenRow] = $content;
                    $updatedBase = true;
                }

                // Overlay selezione: applica solo se cambiata oppure se la base è stata aggiornata
                $selInfo = null;
                $sel = $w->selectionBounds();
                if ($sel && $bufRow >= $sel[0][0] && $bufRow <= $sel[1][0]) {
                    $startCol = ($bufRow === $sel[0][0]) ? $sel[0][1] : 0;
                    $endCol = ($bufRow === $sel[1][0]) ? $sel[1][1] : strlen($visual);
                    if ($endCol > $startCol) {
                        $startCol = max(0, $startCol - $w->hscroll);
                        $length = min($endCol - $w->hscroll - $startCol, max(0, $w->width - $startCol));
                        if ($length > 0) {
                            $seg = substr($visual, $w->hscroll + $startCol, $length);
                            $selInfo = ['start'=>$startCol, 'len'=>$length, 'seg'=>$seg];
                        }
                    }
                }
                $prevSel = $this->lastSelSeg[$screenRow] ?? null;
                if ($updatedBase) {
                    if ($selInfo !== null) {
                        $out .= Ansi::move($screenRow, 1 + $selInfo['start']).Ansi::color(Palette::selection()).$selInfo['seg'].Ansi::reset();
                    }
                    $this->lastSelSeg[$screenRow] = $selInfo;
                } else if (($selInfo === null && $prevSel !== null) || ($selInfo !== null && $prevSel !== null && ($selInfo['start'] !== $prevSel['start'] || $selInfo['len'] !== $prevSel['len'] || $selInfo['seg'] !== $prevSel['seg'])) || ($selInfo !== null && $prevSel === null)) {
                    // Se l'overlay è cambiato ma la base non è stata aggiornata, ridisegna la riga base e poi l'overlay
                    $out .= Ansi::move($screenRow, 1).Ansi::clearLine().$content;
                    if ($selInfo !== null) {
                        $out .= Ansi::move($screenRow, 1 + $selInfo['start']).Ansi::color(Palette::selection()).$selInfo['seg'].Ansi::reset();
                    }
                    $this->lastSelSeg[$screenRow] = $selInfo;
                    $this->lastLineContent[$screenRow] = $content;
                }
            }
            // Se c'è una finestra successiva, disegna separatore orizzontale (differenziale)
            if (count($this->windows) > 1 && $wi === 0) {
                $sepRow = $w->topRow + $w->height;
                $sepContent = Ansi::color(Palette::activeStatus()).str_repeat(' ', $cols).Ansi::reset();
                if (($this->lastLineContent[$sepRow] ?? null) !== $sepContent) {
                    $out .= Ansi::move($sepRow, 1).Ansi::clearLine().$sepContent;
                    $this->lastLineContent[$sepRow] = $sepContent;
                    $this->lastSelSeg[$sepRow] = null;
                }
            }
        }

        // Status bar (differenziale)
        $status = ($this->buf->dirty ? '*' : '-') . ' ' . ($this->buf->filePath !== '' ? $this->buf->filePath : '[No Name]');
        $act = $this->windows[$this->activeIndex];
        $pos = 'Ln '.($act->cursorRow+1).', Col '.($act->cursorCol+1);
        $right = $pos;
        $left = $status.'  '.($this->statusMsg !== '' ? $this->statusMsg : '');
        $space = max(0, $this->term->cols - strlen($left) - strlen($right));
        $bar = Ansi::color(Palette::activeStatus()).str_pad($left, $this->term->cols - strlen($right) - $space, ' ').str_repeat(' ', $space).$right.Ansi::reset();
        if ($this->lastStatusBar !== $bar) {
            $out .= Ansi::move($this->term->rows, 1).Ansi::clearLine().$bar;
            $this->lastStatusBar = $bar;
        }

        // Place cursor
        $cur = $this->windows[$this->activeIndex];
        $cur->clampCursor($this->buf);
        $cur->ensureCursorVisible($this->buf);
        $cursorRowOnScreen = $cur->topRow + ($cur->cursorRow - $cur->scrollTop);
        $cursorColOnScreen = 1 + max(0, $cur->cursorCol - $cur->hscroll);
        $out .= Ansi::move($cursorRowOnScreen, $cursorColOnScreen).Ansi::showCursor();

        fwrite(STDOUT, $out);
    }

    // Prende una stringa con sequenze ANSI e restituisce una slice per colonne visive [start, start+width)
    private static function sliceAnsi(string $s, int $start, int $width): string {
        $out = ''; $vis = 0; $i = 0; $len = strlen($s);
        $collect = false; $end = $start + $width;
        while ($i < $len && $vis < $end) {
            $ch = $s[$i];
            if ($ch === "\x1b") { // copia intera sequenza SGR senza contare colonne
                $m = null;
                if (preg_match('/\x1b\[[0-9;]*m/', substr($s, $i), $m)) {
                    if ($vis >= $start) { $out .= $m[0]; }
                    $i += strlen($m[0]);
                    continue;
                }
            }
            if ($vis >= $start && $vis < $end) { $out .= $ch; }
            $vis++; $i++;
        }
        return $out;
    }
}

// ---- Key handling ----
final class Keys {
    public const CTRL = 1; // value is ord(letter)
    public const ALT = 2;  // value is char
    public const ARROW = 3; // value 'up','down','left','right'
    public const SPECIAL = 4; // 'home','end','pgup','pgdn','del','backspace','enter','tab'
    public const ASCII = 5; // printable char
}

final class Input {
    private ?array $pending = null; // for Ctrl-x prefix handling

    public function readKey(): array {
        // Wait for a byte
        $c = fread(STDIN, 1);
        while ($c === '' || $c === false) { usleep(10000); $c = fread(STDIN, 1); }

        // Enter prima, per evitare che CR venga interpretato come Ctrl+M
        if ($c === "\r" || $c === "\n") return [Keys::SPECIAL, 'enter'];
        // Tab prima dei CTRL (altrimenti diventa Ctrl+i)
        if ($c === "\t") return [Keys::SPECIAL, 'tab'];

        $ord = ord($c);
        // Ctrl keys: 1..26 map to Ctrl+A..Ctrl+Z (Ctrl+Space is NUL -> 0)
        if ($ord === 0) { return [Keys::CTRL, ' ']; }
        if ($ord >= 1 && $ord <= 26) {
            return [Keys::CTRL, chr($ord + 96)];
        }
        if ($ord === 127) return [Keys::SPECIAL, 'backspace'];
        if ($c === "\x1b") { // ESC sequences
            $seq = $c;
            // Try to read rest (non-blocking). Wait briefly
            usleep(1000);
            $seq .= (fread(STDIN, 16) ?: '');
            // Arrows and keys: handle CSI sequences with optional modifier like ;5 (Ctrl)
            if (preg_match('/\x1b\[([0-9]+)(?:;([0-9]+))?~/', $seq, $m)) {
                $n = intval($m[1]); $mod = isset($m[2]) ? intval($m[2]) : 0;
                $spec = ['1'=>'home','3'=>'del','4'=>'end','5'=>'pgup','6'=>'pgdn','7'=>'home','8'=>'end'][$n] ?? '';
                if ($spec !== '') {
                    if ($mod === 5 && ($n===5 || $n===6)) { // Ctrl+PgUp/PgDn
                        return [Keys::SPECIAL, $n===5 ? 'ctrl_pgup' : 'ctrl_pgdn'];
                    }
                    return [Keys::SPECIAL, $spec];
                }
            }
            // Home/End alternate forms: ESC [ H / ESC [ F, or ESC O H / ESC O F
            if (preg_match('/\x1b\[(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            // CSI 1;5H/1;5F etc (con modificatori)
            if (preg_match('/\x1b\[(?:1;\d+)(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1bO(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            // Arrows with optional modifiers: ESC [ 1 ; 5 A  (Ctrl+Up), etc.
            if (preg_match('/\x1b\[(?:1;([0-9]+))?([ABCD])/', $seq, $m)) {
                $mod = isset($m[1]) ? intval($m[1]) : 0; $code = $m[2];
                if ($mod === 5 && ($code === 'A' || $code === 'B')) { // Ctrl + Up/Down
                    return [Keys::SPECIAL, $code === 'A' ? 'ctrl_up' : 'ctrl_down'];
                }
                $map = ['A'=>'up','B'=>'down','C'=>'right','D'=>'left'];
                return [Keys::ARROW, $map[$code]];
            }
            // Alt+key: ESC <char>
            $rest = substr($seq, 1);
            if ($rest !== '') {
                $k = $rest[0];
                // Alt+Backspace variants
                if ($k === "\x7f" || $k === "\x08") { return [Keys::ALT, 'backspace']; }
                // Alt combined with slash or letters
                return [Keys::ALT, $k];
            }
            return [Keys::ASCII, "\x1b"];
        }
        if ($ord >= 32 && $ord <= 126) {
            return [Keys::ASCII, $c];
        }
        return [Keys::ASCII, ''];
    }

    // Non-blocking: restituisce null se non c'è input immediatamente disponibile
    public function readKeyNow(): ?array {
        $c = fread(STDIN, 1);
        if ($c === '' || $c === false) { return null; }

        if ($c === "\r" || $c === "\n") return [Keys::SPECIAL, 'enter'];
        if ($c === "\t") return [Keys::SPECIAL, 'tab'];

        $ord = ord($c);
        if ($ord === 0) { return [Keys::CTRL, ' ']; }
        if ($ord >= 1 && $ord <= 26) { return [Keys::CTRL, chr($ord + 96)]; }
        if ($ord === 127) return [Keys::SPECIAL, 'backspace'];
        if ($c === "\x1b") {
            $seq = $c;
            usleep(1000);
            $seq .= (fread(STDIN, 16) ?: '');
            if (preg_match('/\x1b\[([0-9]+)(?:;([0-9]+))?~/', $seq, $m)) {
                $n = intval($m[1]); $mod = isset($m[2]) ? intval($m[2]) : 0;
                $spec = ['1'=>'home','3'=>'del','4'=>'end','5'=>'pgup','6'=>'pgdn','7'=>'home','8'=>'end'][$n] ?? '';
                if ($spec !== '') {
                    if ($mod === 5 && ($n===5 || $n===6)) { return [Keys::SPECIAL, $n===5 ? 'ctrl_pgup' : 'ctrl_pgdn']; }
                    return [Keys::SPECIAL, $spec];
                }
            }
            if (preg_match('/\x1b\[(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1b\[(?:1;\d+)(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1bO(H|F)/', $seq, $m)) { return [Keys::SPECIAL, $m[1]==='H' ? 'home' : 'end']; }
            if (preg_match('/\x1b\[(?:1;([0-9]+))?([ABCD])/', $seq, $m)) {
                $mod = isset($m[1]) ? intval($m[1]) : 0; $code = $m[2];
                if ($mod === 5 && ($code === 'A' || $code === 'B')) { return [Keys::SPECIAL, $code === 'A' ? 'ctrl_up' : 'ctrl_down']; }
                $map = ['A'=>'up','B'=>'down','C'=>'right','D'=>'left'];
                return [Keys::ARROW, $map[$code]];
            }
            $rest = substr($seq, 1);
            if ($rest !== '') {
                $k = $rest[0];
                if ($k === "\x7f" || $k === "\x08") { return [Keys::ALT, 'backspace']; }
                return [Keys::ALT, $k];
            }
            return [Keys::ASCII, "\x1b"];
        }
        if ($ord >= 32 && $ord <= 126) { return [Keys::ASCII, $c]; }
        return null;
    }
}

// ---- Editor Core ----
final class Editor {
    private Terminal $term;
    private Buffer $buf;
    /** @var Window[] */
    private array $wins;
    private int $active = 0;
    private Renderer $renderer;
    private Input $input;
    private string $clipboard = '';
    private bool $ctrlXPrefix = false;
    private array $undoStack = [];
    private int $undoMax = 50;
    private ?array $autocomplete = null; // ['prefix'=>, 'candidates'=>[], 'index'=>int]
    private ?string $lastSearch = null; // last query
    private int $lastSearchRow = 0; // next start row for repeat
    private int $lastSearchCol = 0; // next start col for repeat

    public function __construct(Terminal $term, Buffer $buf) {
        $this->term = $term; $this->buf = $buf;
        $h = $term->rows - 1; $w = $term->cols;
        $this->wins = [new Window(1, $h, $w)];
        $this->renderer = new Renderer($term, $buf, $this->wins);
        $this->input = new Input();
        $this->snapshot();
    }

    private function activeWin(): Window { return $this->wins[$this->active]; }

    private function snapshot(): void {
        // Push full snapshot for simplicity (sufficient for modest files)
        $state = [
            'lines' => $this->buf->lines,
            'dirty' => $this->buf->dirty,
            'cursorRow' => $this->activeWin()->cursorRow,
            'cursorCol' => $this->activeWin()->cursorCol,
            'scrollTop' => $this->activeWin()->scrollTop,
            'hscroll' => $this->activeWin()->hscroll,
            // Memorizza la posizione dell'ultima modifica (post-edit)
            'lastEditRow' => $this->activeWin()->cursorRow,
            'lastEditCol' => $this->activeWin()->cursorCol,
        ];
        $this->undoStack[] = $state;
        if (count($this->undoStack) > $this->undoMax) { array_shift($this->undoStack); }
    }

    private function undo(): void {
        if (count($this->undoStack) <= 1) { $this->setStatus('Nothing to undo'); return; }
        // Con snapshot pre-edit: poppa l'ultimo snapshot e ripristina
        $state = array_pop($this->undoStack);
        // Ripristina buffer e stato cursore
        $this->buf->lines = $state['lines'] ?? $this->buf->lines;
        $this->buf->dirty = $state['dirty'] ?? $this->buf->dirty;
        $w = $this->activeWin();
        // Posiziona il cursore esattamente dove era nello snapshot ripristinato
        $row = min(max(0, (int)($state['cursorRow'] ?? 0)), max(0, $this->buf->lineCount()-1));
        $line = $this->buf->lines[$row] ?? '';
        $col = min(max(0, (int)($state['cursorCol'] ?? 0)), strlen($line));
        $w->cursorRow = $row; $w->cursorCol = $col;
        // Centra la vista sul cursore dopo il ripristino
        $this->recenter();
        // Nessun push: lo stack ora punta allo stato precedente, permettendo ulteriori undo
    }

    private function setStatus(string $msg): void { $this->renderer->setStatus($msg); }

    public function run(): void {
        fwrite(STDOUT, Ansi::clear());
        $this->renderer->draw();
        while (true) {
            $key = $this->input->readKey();
            $handled = $this->dispatchKey($key);
            if ($handled === 'quit') { break; }

            // Coalescing: processa input immediatamente disponibile per ridurre redraw multipli
            $start = microtime(true);
            $steps = 0;
            while (true) {
                $next = $this->input->readKeyNow();
                if ($next === null) { break; }
                $handled = $this->dispatchKey($next);
                if ($handled === 'quit') { break 2; }
                $steps++;
                if ($steps >= 64) { break; }
                if ((microtime(true) - $start) > 0.008) { break; }
            }

            $this->renderer->setWindows($this->wins, $this->active);
            $this->renderer->draw();
        }
    }

    private function dispatchKey(array $key) {
        [$type, $val] = $key;
        $w = $this->activeWin();
        $this->renderer->setStatus('');

        if ($this->ctrlXPrefix) {
            $this->ctrlXPrefix = false;
            if ($type === Keys::CTRL && $val === 's') { $this->saveFile(); return null; }
            if ($type === Keys::CTRL && $val === 'c') { return $this->maybeQuit(); }
            if ($type === Keys::CTRL && $val === 'f') { $this->findFile(); return null; }
            if ($type === Keys::ASCII && $val === 'u') { $this->undo(); return null; }
            if ($type === Keys::ASCII && $val === '2') { $this->splitHorizontal(); return null; }
            if ($type === Keys::ASCII && $val === 'o') { $this->otherWindow(); return null; }
            if ($type === Keys::ASCII && $val === '1') { $this->makeOnlyThisWindow(); return null; }
            if ($type === Keys::ASCII && $val === '0') { $this->closeCurrentWindow(); return null; }
            return null;
        }

        if ($type === Keys::CTRL && $val === 'x') { $this->ctrlXPrefix = true; $this->setStatus('C-x'); return null; }
        if ($type === Keys::CTRL && $val === 's') { $this->incrementalSearch(''); return null; }

        if ($type === Keys::CTRL && $val === ' ') { $w->hasMark = !$w->hasMark; if ($w->hasMark) { $w->markRow=$w->cursorRow; $w->markCol=$w->cursorCol; $this->setStatus('Mark set'); } else { $this->setStatus('Mark cleared'); } return null; }
        if ($type === Keys::CTRL && $val === 'w') { $this->killRegion(); return null; }
        if ($type === Keys::CTRL && $val === 'y') { $this->yank(); return null; }

        if ($type === Keys::ALT && ($val === 'g' || $val === 'G')) { $this->gotoLinePrompt(); return null; }
        if ($type === Keys::CTRL && $val === 'l') { $this->recenter(); return null; }
        if ($type === Keys::CTRL && $val === 'e') { $this->moveEndOfLine(); return null; }
        if ($type === Keys::CTRL && $val === 'a') { $this->moveBeginningOfLine(); return null; }
        if ($type === Keys::ALT && $val === 'd') { $this->killWordForward(); return null; }
        if ($type === Keys::ALT && $val === 'backspace') { $this->backwardKillWord(); return null; }
        if ($type === Keys::ALT && ($val === 'b' || $val === 'B')) { $this->backwardWord(); return null; }
        if ($type === Keys::ALT && ($val === 'f' || $val === 'F')) { $this->forwardWord(); return null; }
        if ($type === Keys::ALT && $val === 'i') { $this->indentRegion(); return null; }
        if ($type === Keys::ALT && $val === '/') { $this->autocomplete(); return null; }
        // Ctrl+Alt+f / Ctrl+Alt+b per saltare tra parentesi corrispondenti
        if ($type === Keys::ALT && $val === "\x06") { $this->jumpToMatchingBracketForward(); return null; } // M-C-f
        if ($type === Keys::ALT && $val === "\x02") { $this->jumpToMatchingBracketBackward(); return null; } // M-C-b
        // ESC ESC ESC cancella mark come in Emacs
        if ($type === Keys::ASCII && $val === "\x1b") { $this->escCount = ($this->escCount ?? 0) + 1; if ($this->escCount >= 3) { $w->hasMark = false; $this->escCount = 0; $this->setStatus(''); } return null; } else { $this->escCount = 0; }

        switch ($type) {
            case Keys::ARROW:
                $this->moveCursor($val);
                return null;
            case Keys::SPECIAL:
                if ($val === 'enter') { $this->newlineWithIndent(); return null; }
                if ($val === 'backspace') { $this->backspace(); return null; }
                if ($val === 'del') { $this->deleteForward(); return null; }
                if ($val === 'home') { $this->moveBeginningOfLine(); return null; }
                if ($val === 'end') { $this->moveEndOfLine(); return null; }
                if ($val === 'ctrl_pgup') { $this->jumpBlankBlock(-1); return null; }
                if ($val === 'ctrl_pgdn') { $this->jumpBlankBlock(1); return null; }
                if ($val === 'ctrl_up') { $this->jumpBlankBlock(-1); return null; }
                if ($val === 'ctrl_down') { $this->jumpBlankBlock(1); return null; }
                if ($val === 'pgup') { $w->cursorRow = max(0, $w->cursorRow - max(1,$w->height-1)); return null; }
                if ($val === 'pgdn') { $w->cursorRow = min($this->buf->lineCount()-1, $w->cursorRow + max(1,$w->height-1)); return null; }
                if ($val === 'tab') { $this->indentCurrentOrRegion(); return null; }
                return null;
            case Keys::ASCII:
                if ($val !== '') { if ($val === "\f") { $this->recenter(); return null; } $this->insertChar($val); return null; }
                return null;
        }
        return null;
    }

    private function insertChar(string $ch): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w = $this->activeWin(); $row = $w->cursorRow; $col = $w->cursorCol;
        $line = $this->buf->lines[$row] ?? '';
        // Outdent if first non-space is )}] and we are at leading spaces
        if (($ch === ')' || $ch === ']' || $ch === '}') && preg_match('/^\s*$/', substr($line, 0, $col))) {
            if (strlen($line) > 0 && $col > 0) {
                $pre = substr($line, 0, max(0, $col-1));
                $post = substr($line, $col);
                $line = $pre.$post; $w->cursorCol = max(0, $col-1); $col = $w->cursorCol;
            }
        }
        $newline = substr($line, 0, $col).$ch.substr($line, $col);
        $this->buf->lines[$row] = $newline;
        $w->cursorCol++;
        $this->buf->dirty = true;
        $this->autocomplete = null; // reset cycle
    }

    private function backspace(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w = $this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        if ($col > 0) {
            $line = $this->buf->lines[$row];
            $this->buf->lines[$row] = substr($line, 0, $col-1).substr($line, $col);
            $w->cursorCol--; $this->buf->dirty = true;
            return;
        }
        if ($row > 0) {
            $prev = $this->buf->lines[$row-1];
            $line = $this->buf->lines[$row];
            $joinCol = strlen($prev);
            $this->buf->lines[$row-1] = $prev.$line;
            array_splice($this->buf->lines, $row, 1);
            $w->cursorRow--; $w->cursorCol = $joinCol; $this->buf->dirty = true;
        }
    }

    private function deleteForward(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        $line = $this->buf->lines[$row];
        if ($col < strlen($line)) {
            $this->buf->lines[$row] = substr($line, 0, $col).substr($line, $col+1);
            $this->buf->dirty = true;
        } else if ($row < $this->buf->lineCount()-1) {
            $next = $this->buf->lines[$row+1];
            $this->buf->lines[$row] = $line.$next;
            array_splice($this->buf->lines, $row+1, 1);
            $this->buf->dirty = true;
        }
    }

    private function newlineWithIndent(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        $line = $this->buf->lines[$row];
        $before = substr($line, 0, $col); $after = substr($line, $col);
        $indent = preg_match('/^(\s*)/', $before, $m) ? strlen($m[1]) : 0;
        $trimPrev = rtrim($before);
        $last = $trimPrev === '' ? '' : $trimPrev[strlen($trimPrev)-1];
        if ($last === '{') { $indent += 1; }
        // Se la parte dopo inizia con '}', riduci
        if (preg_match('/^\s*\}/', $after)) { $indent = max(0, $indent - 1); }
        // Indenta usando TAB: converte spazi/tabs di indent in TAB logici
        $newLineStr = str_repeat("\t", max(0,$indent));
        $this->buf->lines[$row] = $before;
        array_splice($this->buf->lines, $row+1, 0, [$newLineStr.$after]);
        $w->cursorRow++; $w->cursorCol = $indent;
        $this->buf->dirty = true;
    }

    private function moveCursor(string $dir): void {
        $w=$this->activeWin();
        if ($dir === 'left') {
            if ($w->cursorCol > 0) { $w->cursorCol--; }
            else if ($w->cursorRow > 0) { $w->cursorRow--; $w->cursorCol = strlen($this->buf->lines[$w->cursorRow]); }
        } elseif ($dir === 'right') {
            $line = $this->buf->lines[$w->cursorRow];
            if ($w->cursorCol < strlen($line)) { $w->cursorCol++; }
            else if ($w->cursorRow < $this->buf->lineCount()-1) { $w->cursorRow++; $w->cursorCol = 0; }
        } elseif ($dir === 'up') {
            if ($w->cursorRow > 0) { $w->cursorRow--; $w->cursorCol = min($w->cursorCol, strlen($this->buf->lines[$w->cursorRow])); }
        } elseif ($dir === 'down') {
            if ($w->cursorRow < $this->buf->lineCount()-1) { $w->cursorRow++; $w->cursorCol = min($w->cursorCol, strlen($this->buf->lines[$w->cursorRow])); }
        }
    }

    private function moveEndOfLine(): void {
        $w=$this->activeWin();
        $line = $this->buf->lines[$w->cursorRow] ?? '';
        $w->cursorCol = strlen($line);
        // assicurati che l'ultimo carattere sia visibile
        $w->hscroll = max(0, $w->cursorCol - intdiv(max(1,$w->width-1), 1));
    }

    private function moveBeginningOfLine(): void {
        $w=$this->activeWin();
        $w->cursorCol = 0;
    }

    private function isWordChar(string $ch): bool { return ctype_alnum($ch) || $ch === '_' || $ch === '$'; }

    private function forwardWord(): void {
        $w=$this->activeWin(); $line = $this->buf->lines[$w->cursorRow] ?? '';
        $i = $w->cursorCol; $n = strlen($line);
        while ($i < $n && !$this->isWordChar($line[$i])) $i++;
        while ($i < $n && $this->isWordChar($line[$i])) $i++;
        $w->cursorCol = $i;
    }

    private function backwardWord(): void {
        $w=$this->activeWin(); $line = $this->buf->lines[$w->cursorRow] ?? '';
        $i = $w->cursorCol - 1;
        while ($i > 0 && !$this->isWordChar($line[$i])) $i--;
        while ($i > 0 && $this->isWordChar($line[$i-1])) $i--;
        $w->cursorCol = max(0,$i);
    }

    private function killWordForward(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol; $line = $this->buf->lines[$row] ?? '';
        $i = $col; $n = strlen($line);
        while ($i < $n && !$this->isWordChar($line[$i])) $i++;
        while ($i < $n && $this->isWordChar($line[$i])) $i++;
        $kill = substr($line, $col, $i-$col);
        $this->clipboard = $kill;
        $this->buf->lines[$row] = substr($line, 0, $col).substr($line, $i);
        $this->buf->dirty = true;
    }

    private function backwardKillWord(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol; $line = $this->buf->lines[$row] ?? '';
        $i = $col;
        while ($i > 0 && !$this->isWordChar($line[$i-1])) $i--;
        while ($i > 0 && $this->isWordChar($line[$i-1])) $i--;
        $kill = substr($line, $i, $col-$i);
        $this->clipboard = $kill;
        $this->buf->lines[$row] = substr($line, 0, $i).substr($line, $col);
        $w->cursorCol = $i;
        $this->buf->dirty = true;
    }

    private function recenter(): void {
        $w=$this->activeWin();
        $w->scrollTop = max(0, $w->cursorRow - intdiv($w->height, 2));
        $w->hscroll = max(0, $w->cursorCol - intdiv(max(1,$w->width-1), 2));
        $this->renderer->setWindows($this->wins, $this->active);
        $this->renderer->draw();
    }

    private function recenterIfOffscreen(): void {
        $w=$this->activeWin();
        $visibleTop = $w->scrollTop;
        $visibleBottom = $w->scrollTop + max(1, $w->height-1) - 1;
        if ($w->cursorRow < $visibleTop || $w->cursorRow > $visibleBottom) {
            $this->recenter();
        }
    }

    private function jumpBlankBlock(int $dir): void {
        $w=$this->activeWin(); $row=$w->cursorRow; $n=$this->buf->lineCount();
        $found = $row;
        if ($dir < 0) {
            for ($r=$row-1; $r>=0; $r--) { if (trim($this->buf->lines[$r]) === '') { $found = max(0,$r-1); break; } }
        } else {
            for ($r=$row+1; $r<$n; $r++) { if (trim($this->buf->lines[$r]) === '') { $found = min($n-1,$r+1); break; } }
        }
        $w->cursorRow = $found; $w->cursorCol = 0; $w->ensureCursorVisible($this->buf);
        // recenter per velocità visiva
        $this->recenter();
    }

    private function jumpToMatchingBracketForward(): void {
        $w = $this->activeWin();
        [$row,$col] = [$w->cursorRow, $w->cursorCol];
        $line = $this->buf->lines[$row] ?? '';
        $startChar = null; $startRow = $row; $startCol = $col;
        $opens = ['('=>')','['=>']','{'=>'}'];
        $closes = array_flip($opens);
        $c = ($col < strlen($line)) ? $line[$col] : null;
        $cPrev = ($col > 0 && $col-1 < strlen($line)) ? $line[$col-1] : null;
        if ($c !== null && isset($opens[$c])) { $startChar = $c; $startCol = $col; }
        elseif ($cPrev !== null && isset($opens[$cPrev])) { $startChar = $cPrev; $startCol = $col-1; }
        else {
            // Allarga: cerca un'aperta visibile a sinistra sulla stessa riga
            $k = $col-1; while ($k >= 0 && ($line[$k] === ' ' || $line[$k] === "\t")) { $k--; }
            if ($k >= 0 && isset($opens[$line[$k]])) { $startChar = $line[$k]; $startCol = $k; }
            // Se non trovata e siamo a inizio riga, guarda la riga precedente
            if ($startChar === null && $col === 0 && $row > 0) {
                $pl = $this->buf->lines[$row-1]; $k = strlen($pl) - 1;
                while ($k >= 0 && ($pl[$k] === ' ' || $pl[$k] === "\t")) { $k--; }
                if ($k >= 0 && isset($opens[$pl[$k]])) { $startChar = $pl[$k]; $startRow = $row-1; $startCol = $k; }
            }
            if ($startChar === null) { $this->setStatus('No opening bracket at point'); return; }
        }
        $target = $opens[$startChar];
        $depth = 1; $r = $startRow; $cidx = $startCol;
        $inStr = null; $escaped = false; $inLineComment = false; $inBlockComment = false;
        while (true) {
            // advance one char
            $cidx++;
            while (true) {
                $ln = $this->buf->lines[$r] ?? null;
                if ($ln === null) { $this->setStatus('No match'); return; }
                if ($cidx < strlen($ln)) { break; }
                // new line
                $r++; $cidx = 0; $inLineComment = false; $escaped = false; // reset comment at newline
            }
            $ch = $this->buf->lines[$r][$cidx];
            if ($inLineComment) { continue; }
            if ($inBlockComment) { if ($ch === '*' && ($cidx+1) < strlen($this->buf->lines[$r]) && $this->buf->lines[$r][$cidx+1] === '/') { $inBlockComment = false; $cidx++; } continue; }
            if ($inStr !== null) {
                if ($escaped) { $escaped = false; continue; }
                if ($ch === '\\') { $escaped = true; continue; }
                if ($ch === $inStr) { $inStr = null; }
                continue;
            }
            // Start string or line comment
            if ($ch === '"' || $ch === "'") { $inStr = $ch; continue; }
            if ($ch === '/' && ($cidx+1) < strlen($this->buf->lines[$r]) && $this->buf->lines[$r][$cidx+1] === '/') { $inLineComment = true; continue; }
            if ($ch === '/' && ($cidx+1) < strlen($this->buf->lines[$r]) && $this->buf->lines[$r][$cidx+1] === '*') { $inBlockComment = true; $cidx++; continue; }
            if ($ch === '#') { $inLineComment = true; continue; }
            // Depth tracking: considera SOLO lo stesso tipo di parentesi
            if ($ch === $startChar) { $depth++; continue; }
            if ($ch === $target) { $depth--; if ($depth === 0) { $w->cursorRow = $r; $w->cursorCol = $cidx; $this->recenterIfOffscreen(); return; } }
        }
    }

    private function jumpToMatchingBracketBackward(): void {
        $w = $this->activeWin();
        [$row,$col] = [$w->cursorRow, $w->cursorCol];
        $line = $this->buf->lines[$row] ?? '';
        $opens = ['('=>')','['=>']','{'=>'}'];
        $closes = array_flip($opens);
        $startChar = null; $startRow = $row; $startCol = $col;
        $c = ($col > 0) ? $line[$col-1] : null; // char before cursor
        $cHere = ($col < strlen($line)) ? $line[$col] : null;
        if ($cHere !== null && isset($closes[$cHere])) { $startChar = $cHere; $startCol = $col; }
        elseif ($c !== null && isset($closes[$c])) { $startChar = $c; $startCol = $col-1; }
        else { $this->setStatus('No closing bracket at point'); return; }
        $target = $closes[$startChar];
        $depth = 1; $r = $startRow; $cidx = $startCol;
        $inStr = null; $escaped = false; $inLineComment = false; $inBlockComment = false;
        while (true) {
            // move back one char
            $cidx--;
            while ($cidx < 0) {
                $r--; if ($r < 0) { $this->setStatus('No match'); return; }
                $ln = $this->buf->lines[$r];
                $cidx = strlen($ln) - 1; $inLineComment = false; $escaped = false;
            }
            $ch = $this->buf->lines[$r][$cidx];
            if ($inLineComment) { continue; }
            if ($inBlockComment) { if ($ch === '/' && $cidx > 0 && $this->buf->lines[$r][$cidx-1] === '*') { $inBlockComment = false; $cidx--; } continue; }
            if ($inStr !== null) {
                // naive skip backwards: exit string when same quote seen not escaped
                if ($ch === $inStr && !$escaped) { $inStr = null; continue; }
                if ($ch === '\\' && !$escaped) { $escaped = true; continue; }
                $escaped = false; continue;
            }
            // Enter string or ignore comments when scanning backward (best-effort)
            if ($ch === '"' || $ch === "'") { $inStr = $ch; $escaped = true; continue; }
            if ($ch === '/' && $cidx > 0 && $this->buf->lines[$r][$cidx-1] === '*') { $inBlockComment = true; $cidx--; continue; }
            // Depth tracking: considera SOLO lo stesso tipo di parentesi
            if ($ch === $startChar) { $depth++; continue; }
            if ($ch === $target) { $depth--; if ($depth === 0) { $w->cursorRow = $r; $w->cursorCol = $cidx; $this->recenterIfOffscreen(); return; } }
        }
    }

    private function regionText(Window $w): ?array {
        $sel = $w->selectionBounds();
        if (!$sel) { return null; }
        [$a, $b] = $sel; // [row,col]
        $lines = [];
        for ($r=$a[0]; $r<=$b[0]; $r++) {
            $line = $this->buf->lines[$r];
            $start = ($r===$a[0]) ? $a[1] : 0;
            $end = ($r===$b[0]) ? $b[1] : strlen($line);
            $lines[] = substr($line, $start, max(0,$end-$start));
        }
        return [$a,$b,$lines];
    }

    private function killRegion(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w=$this->activeWin(); $rg = $this->regionText($w);
        if (!$rg) { $this->setStatus('No selection'); return; }
        [$a,$b,$lines] = $rg; $this->clipboard = implode("\n", $lines);
        // Delete region
        if ($a[0] === $b[0]) {
            $line = $this->buf->lines[$a[0]];
            $this->buf->lines[$a[0]] = substr($line, 0, $a[1]).substr($line, $b[1]);
        } else {
            $first = substr($this->buf->lines[$a[0]], 0, $a[1]);
            $last = substr($this->buf->lines[$b[0]], $b[1]);
            $newFirst = $first.$last;
            array_splice($this->buf->lines, $a[0], $b[0]-$a[0]+1, [$newFirst]);
        }
        $w->cursorRow = $a[0]; $w->cursorCol = $a[1];
        $w->hasMark = false; $this->buf->dirty = true;
        $this->setStatus('Killed');
    }

    private function yank(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        if ($this->clipboard === '') { $this->setStatus('Clipboard empty'); return; }
        $w=$this->activeWin(); $row=$w->cursorRow; $col=$w->cursorCol;
        $lines = explode("\n", $this->clipboard);
        if (count($lines) === 1) {
            $line = $this->buf->lines[$row];
            $this->buf->lines[$row] = substr($line, 0, $col).$lines[0].substr($line, $col);
            $w->cursorCol = $col + strlen($lines[0]);
        } else {
            $line = $this->buf->lines[$row];
            $first = substr($line, 0, $col).$lines[0];
            $last = substr($line, $col);
            $mid = array_slice($lines, 1, -1);
            $end = end($lines);
            $newLines = array_merge([$first], $mid, [$end.$last]);
            array_splice($this->buf->lines, $row, 1, $newLines);
            $w->cursorRow = $row + count($newLines)-1; $w->cursorCol = strlen($end);
        }
        $this->buf->dirty = true;
        $this->setStatus('Yanked');
    }

    private function indentRegion(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w=$this->activeWin(); $sel = $w->selectionBounds();
        if (!$sel) { $this->setStatus('No selection'); return; }
        [$a,$b] = $sel;
        for ($r=$a[0]; $r<=$b[0]; $r++) {
            $line = $this->buf->lines[$r];
            // Indenta come Emacs: porta la riga all'indent desiderato
            $desired = $this->desiredIndentForRow($r);
            // Costruisci prefisso di TAB
            $prefix = str_repeat("\t", max(0, $desired));
            $this->buf->lines[$r] = $prefix.ltrim($line, " \t");
        }
        // Posiziona il cursore alla colonna dell'indent desiderato
        if ($w->cursorRow >= $a[0] && $w->cursorRow <= $b[0]) {
            $w->cursorCol = $this->desiredIndentForRow($w->cursorRow);
        }
        $this->buf->dirty = true;
        $this->setStatus('Indented');
    }

    private function indentCurrentOrRegion(): void {
        // Snapshot prima della modifica
        $this->snapshot();
        $w=$this->activeWin();
        $sel = $w->selectionBounds();
        if ($sel) { $this->indentRegion(); return; }
        $row = $w->cursorRow;
        $desired = $this->desiredIndentForRow($row);
        $this->buf->lines[$row] = str_repeat("\t", max(0,$desired)).ltrim($this->buf->lines[$row], " \t");
        $w->cursorCol = $desired;
        $this->buf->dirty = true;
        $this->setStatus('Indented');
    }

    private function desiredIndentForRow(int $row): int {
        // Conta solo graffe { } fino alla riga precedente, ignorando stringhe e commenti
        $depth = 0; $inStr = null; $escaped = false; $inLineComment = false;
        for ($r = 0; $r < $row; $r++) {
            $ln = $this->buf->lines[$r] ?? '';
            $inLineComment = false; $inStr = null; $escaped = false;
            $len = strlen($ln);
            for ($i=0; $i<$len; $i++) {
                $ch = $ln[$i];
                if ($inLineComment) break;
                if ($inStr !== null) {
                    if ($escaped) { $escaped = false; continue; }
                    if ($ch === '\\') { $escaped = true; continue; }
                    if ($ch === $inStr) { $inStr = null; }
                    continue;
                }
                if ($ch === '"' || $ch === "'") { $inStr = $ch; continue; }
                if ($ch === '/' && $i+1<$len && $ln[$i+1] === '/') { $inLineComment = true; break; }
                if ($ch === '{') $depth++;
                if ($ch === '}') $depth = max(0,$depth-1);
            }
        }
        $cur = $this->buf->lines[$row] ?? '';
        if (preg_match('/^\s*\}/', $cur)) { $depth = max(0, $depth - 1); }
        return $depth;
    }

    private function gotoLinePrompt(): void {
        $num = $this->miniPrompt('Goto line: ');
        if ($num === null || $num === '') { return; }
        $line = max(1, (int)$num); $line = min($line, $this->buf->lineCount());
        $w=$this->activeWin();
        $w->cursorRow = $line-1; $w->cursorCol = 0;
        // centra la vista subito, non aspettare altri input
        $w->scrollTop = max(0, $w->cursorRow - intdiv($w->height,2));
        $this->renderer->setWindows($this->wins, $this->active);
        $this->renderer->draw();
        $this->setStatus('');
    }

    private function autocomplete(): void {
        $w=$this->activeWin(); $line = $this->buf->lines[$w->cursorRow]; $col=$w->cursorCol;
        if (!preg_match('/[A-Za-z_][A-Za-z0-9_]*$/', substr($line, 0, $col), $m)) { $this->setStatus('No prefix'); return; }
        $prefix = $m[0];
        if ($this->autocomplete && $this->autocomplete['prefix'] === $prefix) {
            $i = $this->autocomplete['index'] + 1; $cands = $this->autocomplete['candidates'];
            if ($i >= count($cands)) { $i = 0; }
            $this->autocomplete['index'] = $i; $word = $cands[$i];
        } else {
            $keywords = array_unique(array_merge(Highlighter::$phpKeywords ?? [], Highlighter::$jsKeywords ?? [], ['function','return','class','public','private','protected','var','let','const','echo']));
            $bufText = implode("\n", $this->buf->lines);
            preg_match_all('/[A-Za-z_][A-Za-z0-9_]*/', $bufText, $all);
            $cands = array_values(array_unique(array_filter(array_merge($keywords, $all[0]), function($w) use ($prefix){ return strpos($w, $prefix)===0 && $w!==$prefix; })));
            if (!$cands) { $this->setStatus('No matches'); return; }
            sort($cands, SORT_STRING);
            $this->autocomplete = ['prefix'=>$prefix, 'candidates'=>$cands, 'index'=>0];
            $word = $cands[0];
        }
        // Replace prefix with word
        $start = $col - strlen($prefix);
        $this->buf->lines[$w->cursorRow] = substr($line, 0, $start).$word.substr($line, $col);
        $w->cursorCol = $start + strlen($word);
        $this->buf->dirty = true; $this->snapshot();
        $this->setStatus($word);
    }

    private function miniPrompt(string $prompt): ?string {
        // Readline-like minimal prompt in status bar
        $input = '';
        $this->renderer->setStatus($prompt.$input);
        $this->renderer->draw();
        while (true) {
            $k = (new Input())->readKey();
            [$t,$v] = $k;
            if ($t === Keys::SPECIAL && $v === 'enter') break;
            if ($t === Keys::CTRL && $v === 'g') { $input = null; break; }
            if ($t === Keys::SPECIAL && $v === 'backspace') { if ($input !== '') { $input = substr($input,0,-1); } }
            elseif ($t === Keys::ASCII && $v !== '') { if (ctype_digit($v)) { $input .= $v; } }
            $this->renderer->setStatus($prompt.$input);
            $this->renderer->draw();
        }
        $this->renderer->setStatus('');
        return $input;
    }

    private function filePrompt(string $cwd, string $initial = ''): ?string {
        $input = $initial;
        $dir = $cwd;
        $showList = true; $list = []; $sel = 0; $baseDir = $dir; $prefix = '';
        while (true) {
            // Aggiorna status
            $this->renderer->setStatus('Find file ['.$dir.']: '.$input);
            $this->renderer->draw();
            // Disegna lista se richiesta (ultime N righe prima della status bar)
            if ($showList) {
                // Se non siamo in modalità filtri (baseDir non derivato da tab) usa la dir corrente
                if ($baseDir === '' || $baseDir === $dir) {
                    $baseDir = $dir;
                    $cands = @scandir($baseDir) ?: [];
                    $cands = array_values(array_filter($cands, function($e){ return $e !== '.'; }));
                    usort($cands, function($a,$b) use ($baseDir){
                        $da = is_dir(($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$a);
                        $db = is_dir(($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$b);
                        if ($da === $db) return strcmp($a,$b);
                        return $da ? -1 : 1;
                    });
                    $list = array_map(function($e) use ($baseDir){ return $e.(is_dir(($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$e) ? '/' : ''); }, $cands);
                    if ($sel >= count($list)) { $sel = max(0, count($list)-1); }
                }
                $rows = max(1, min(8, $this->term->rows - 2));
                $startRow = $this->term->rows - 1 - $rows; // sopra la status bar
                // Preparazione voci (mostra directory con /)
                $toShow = array_slice($list, 0, $rows);
                for ($i=0; $i<$rows; $i++) {
                    $label = $toShow[$i] ?? '';
                    $isSel = ($i === $sel);
                    $padded = str_pad($label, max(0, $this->term->cols-0));
                    fwrite(STDOUT, Ansi::move($startRow + $i, 1)
                                   .Ansi::clearLine()
                                   .($isSel ? Ansi::color(Palette::selection()) : '')
                                   .$padded
                                   .($isSel ? Ansi::reset() : ''));
                }
            }

            $k = (new Input())->readKey();
            [$t,$v] = $k;
            if ($t === Keys::SPECIAL && $v === 'enter') {
                if ($showList && isset($list[$sel])) {
                    $pick = $list[$sel];
                    $path = ($baseDir === '/' ? '/' : rtrim($baseDir,'/').'/').$pick;
                } else {
                    $path = $input;
                    if ($path === '') { continue; }
                    if ($path[0] !== '/' && $path[0] !== '~') { $path = rtrim($dir,'/').'/'.$path; }
                }
                // espandi tilde
                if ($path[0] === '~') { $home = getenv('HOME') ?: '/'; $path = $home.substr($path,1); }
                if (is_dir($path)) { $dir = realpath($path) ?: $path; $input = ''; $showList = true; $list=[]; $sel=0; $baseDir=$dir; continue; }
                return $path;
            }
            if ($t === Keys::CTRL && $v === 'g') { $this->renderer->setStatus(''); return null; }
            if ($t === Keys::ASCII && $v === "\x1b") { $this->renderer->setStatus(''); return null; }
            if ($t === Keys::SPECIAL && $v === 'backspace') { if ($input !== '') { $input = substr($input,0,-1); } }
            elseif ($t === Keys::ASCII && $v !== '') { $input .= $v; }
            elseif ($t === Keys::SPECIAL && $v === 'tab') {
                // Calcola baseDir e prefix in base all'input
                $prefix = $input;
                $baseDir = $dir;
                if ($prefix !== '' && ($prefix[0] === '/' || $prefix[0] === '~')) {
                    if ($prefix[0] === '~') { $baseDir = getenv('HOME') ?: '/'; $prefix = substr($prefix,1); }
                    $slash = strrpos($prefix, '/');
                    if ($slash !== false) {
                        $baseDir = ($input[0] === '/') ? substr($input,0,$slash) : rtrim($baseDir,'/').'/'.substr($input,0,$slash);
                        $prefix = substr($input, $slash+1);
                    }
                }
                $cands = @scandir($baseDir) ?: [];
                $cands = array_values(array_filter($cands, function($e){ return $e !== '.'; }));
                // directory prime, poi file
                usort($cands, function($a,$b) use ($baseDir){
                    $da = is_dir(($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$a);
                    $db = is_dir(($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$b);
                    if ($da === $db) return strcmp($a,$b);
                    return $da ? -1 : 1;
                });
                $matches = array_values(array_filter($cands, function($e) use ($prefix){ return $prefix === '' || strpos($e, $prefix) === 0; }));
                if (count($matches) === 1) {
                    $single = $matches[0];
                    $input = (strpos($input,'/')!==false ? substr($input,0,strrpos($input,'/')+1) : '').$single;
                    // Se è dir, aggiungi slash per suggerire
                    $abs = ($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$single;
                    if (is_dir($abs)) { $input .= '/'; }
                    $showList = false;
                } else {
                    $showList = true; $list = array_map(function($e) use ($baseDir){ return $e.(is_dir(($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$e) ? '/' : ''); }, $matches); $sel = 0;
                }
            } elseif ($t === Keys::ARROW && $showList) {
                if ($v === 'down') { if ($sel < max(0, min(8,count($list)))-1 && $sel < count($list)-1) { $sel++; } }
                if ($v === 'up') { if ($sel > 0) { $sel--; } }
                if ($v === 'right' && isset($list[$sel])) {
                    $pick = rtrim($list[$sel],'/');
                    $abs = ($baseDir==='/'?'/':rtrim($baseDir,'/').'/').$pick;
                    if (is_dir($abs)) { $dir = realpath($abs) ?: $abs; $input = ''; $showList=true; $list=[]; $sel=0; $baseDir=$dir; }
                }
                if ($v === 'left') {
                    $parent = dirname($dir);
                    if ($parent && $parent !== $dir) { $dir = $parent; $input = ''; $showList=true; $list=[]; $sel=0; $baseDir=$dir; }
                }
            }
        }
    }

    private function findFile(): void {
        $cwd = getcwd() ?: '.';
        $path = $this->filePrompt($cwd, '');
        if ($path === null) { $this->renderer->setStatus('Cancelled'); return; }
        if (is_dir($path)) { $this->renderer->setStatus('Is a directory'); return; }
        if (!is_file($path)) {
            $parent = dirname($path);
            if (!is_dir($parent)) { $this->setStatus('Directory not found'); return; }
            @touch($path);
        }
        // Carica nel buffer
        $this->buf->loadFile($path);
        // Reset finestra
        $w=$this->activeWin(); $w->cursorRow=0; $w->cursorCol=0; $w->scrollTop=0; $w->hscroll=0;
        $this->snapshot();
        $this->renderer->setWindows($this->wins, $this->active);
        $this->renderer->draw();
        $this->setStatus('Opened '.$path);
    }

    private function saveFile(): void {
        if ($this->buf->save()) { $this->setStatus('Salvato ✅'); }
        else { $this->setStatus('Errore salvataggio ❌'); }
    }

    private function maybeQuit() {
        if ($this->buf->dirty) {
            $ans = $this->yesNoPrompt('Modified buffer. Quit without saving? (y/n) ');
            if (!$ans) return null;
        }
        return 'quit';
    }

    private function yesNoPrompt(string $msg): bool {
        $this->renderer->setStatus($msg);
        $this->renderer->draw();
        while (true) {
            $k = (new Input())->readKey();
            if ($k[0] === Keys::ASCII) {
                if ($k[1] === 'y' || $k[1] === 'Y') { $this->renderer->setStatus(''); return true; }
                if ($k[1] === 'n' || $k[1] === 'N') { $this->renderer->setStatus(''); return false; }
            }
        }
    }

    // Incremental search (Ctrl+s): barra di ricerca nella status bar, aggiorna match live; ripetere Ctrl+s va al prossimo
    private function incrementalSearch(string $initialQuery = ''): void {
        $query = $initialQuery;
        $startPos = [$this->activeWin()->cursorRow, $this->activeWin()->cursorCol];
        $originRow = $startPos[0];
        $originCol = $startPos[1];
        $this->renderer->setStatus('I-Search: ' . $query);
        $this->renderer->draw();
        if ($query !== '') {
            // mostra la query esistente e posiziona sul primo match dall'origine
            $this->activeWin()->cursorRow = $originRow; $this->activeWin()->cursorCol = $originCol;
            $this->searchNext($query, false, true);
        }
        while (true) {
            $k = (new Input())->readKey();
            [$t,$v] = $k;
            if (($t === Keys::SPECIAL && $v === 'enter') || ($t === Keys::ASCII && $v === "\x1b")) { break; }
            if ($t === Keys::CTRL && $v === 'g') { // abort
                $w=$this->activeWin(); $w->cursorRow=$startPos[0]; $w->cursorCol=$startPos[1]; $this->renderer->setStatus(''); return; }
            if ($t === Keys::CTRL && $v === 's') {
                // Se la query è vuota e esiste una ricerca precedente, auto-inseriscila e cerca subito
                if ($query === '' && ($this->lastSearch ?? '') !== '') {
                    $query = $this->lastSearch;
                    $this->renderer->setStatus('I-Search: '.$query);
                    $this->renderer->draw();
                    // riparti dall'origine e trova il primo match
                    $this->activeWin()->cursorRow = $originRow; $this->activeWin()->cursorCol = $originCol;
                    $this->searchNext($query, false, true);
                    continue;
                }
                // Altrimenti, ripeti la ricerca andando al prossimo match
                $this->searchNext($query, true, true);
                continue;
            }
            if ($t === Keys::SPECIAL && $v === 'backspace') { $query = substr($query,0,-1); }
            elseif ($t === Keys::ASCII && $v !== '') { $query .= $v; }
            $this->renderer->setStatus('I-Search: '.$query);
            $this->renderer->draw();
            // per ogni modifica della query, cerca partendo dall'origine iniziale
            $this->activeWin()->cursorRow = $originRow; $this->activeWin()->cursorCol = $originCol;
            $this->searchNext($query, false, true);
        }
        $this->lastSearch = $query;
        $this->lastSearchRow = $this->activeWin()->cursorRow;
        $this->lastSearchCol = max(0, $this->activeWin()->cursorCol - strlen($query));
        $this->activeWin()->hasMark = false; $this->renderer->setStatus('');
    }

    private function searchNext(string $query, bool $fromAfter, bool $select=false): void {
        if ($query === '') return;
        $w=$this->activeWin(); $n = $this->buf->lineCount();
        $startRow = $w->cursorRow; $startCol = $w->cursorCol + ($fromAfter ? 1 : 0);
        $q = strtolower($query);
        for ($pass=0; $pass<2; $pass++) {
            for ($r = ($pass===0 ? $startRow : 0); $r < $n; $r++) {
                $line = $this->buf->lines[$r]; $hay = strtolower($line);
                $offset = ($pass===0 && $r===$startRow) ? max(0,$startCol) : 0;
                $pos = strpos($hay, $q, $offset);
                if ($pos !== false) {
                    if ($select) { $w->hasMark = true; $w->markRow = $r; $w->markCol = $pos; $w->cursorRow = $r; $w->cursorCol = $pos + strlen($query); }
                    else { $w->cursorRow = $r; $w->cursorCol = $pos; }
                    $w->ensureCursorVisible($this->buf);
                    $this->renderer->setWindows($this->wins, $this->active); $this->renderer->draw();
                    return;
                }
            }
        }
        $this->renderer->setStatus('I-Search: not found');
    }

    private function splitHorizontal(): void {
        if (count($this->wins) === 1) {
            $this->wins[] = new Window(1, 1, $this->term->cols);
        }
        $this->setStatus('Split');
    }

    private function otherWindow(): void {
        if (count($this->wins) > 1) { $this->active = 1 - $this->active; }
    }

    // Ctrl+1: solo il pane attuale
    private function makeOnlyThisWindow(): void {
        if (count($this->wins) > 1) {
            $this->wins = [$this->wins[$this->active]];
            $this->active = 0;
        }
    }

    // Ctrl+0: chiudi il pane attuale
    private function closeCurrentWindow(): void {
        if (count($this->wins) > 1) {
            array_splice($this->wins, $this->active, 1);
            $this->active = 0;
        }
    }
}

// ---- Bootstrap ----
// Supporto a -q (quit immediato dopo il caricamento)
$args = $argv; array_shift($args);
$quitImmediately = false; $fileArg = '';
foreach ($args as $a) { if ($a === '-q') { $quitImmediately = true; } else if ($fileArg === '') { $fileArg = $a; } }
$term = new Terminal();
$buffer = new Buffer($fileArg);
$editor = new Editor($term, $buffer);
// Gestione segnali: assicura ripristino pulito anche su SIGINT/SIGTERM/SIGHUP/SIGQUIT
if (function_exists('pcntl_signal')) {
    $handler = function(int $sig) use ($term) {
        $term->restore();
        fwrite(STDOUT, Ansi::clear()); fflush(STDOUT);
        // Esci con codice che indica segnale
        exit(128 + $sig);
    };
    @pcntl_signal(SIGINT, $handler);
    @pcntl_signal(SIGTERM, $handler);
    @pcntl_signal(SIGHUP, $handler);
    @pcntl_signal(SIGQUIT, $handler);
    // Gestione asincrona: niente bisogno di pcntl_signal_dispatch nel loop
    if (function_exists('pcntl_async_signals')) { @pcntl_async_signals(true); }
}
if ($quitImmediately) {
    $term->restore();
    fwrite(STDOUT, Ansi::clear()); fflush(STDOUT);
} else {
    $editor->run();
    // Ripristina terminale e pulisci esplicitamente lo schermo
    $term->restore();
    fwrite(STDOUT, Ansi::clear()); fflush(STDOUT);
}



